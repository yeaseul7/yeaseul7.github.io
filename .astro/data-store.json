[["Map",1,2,9,10],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.14.8","content-config-digest","aa3455847d3568fa","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"https://yeaseul7.github.io/\",\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"always\",\"output\":\"static\",\"scopedStyleStrategy\":\"where\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image/\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":false,\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[null,null,null],\"rehypePlugins\":[null,[null,{\"experimentalHeadingIdCompat\":false}],null,[null,{\"themes\":[\"vitesse-dark\",\"vitesse-light\"],\"defaultLocale\":\"en\",\"cascadeLayer\":\"starlight.components\",\"styleOverrides\":{\"borderRadius\":\"0.5rem\",\"borderWidth\":\"1px\",\"codePaddingBlock\":\"0.75rem\",\"codePaddingInline\":\"1rem\",\"codeFontFamily\":\"var(--__sl-font-mono)\",\"codeFontSize\":\"var(--sl-text-code)\",\"codeLineHeight\":\"var(--sl-line-height)\",\"uiFontFamily\":\"var(--__sl-font)\",\"textMarkers\":{\"lineDiffIndicatorMarginLeft\":\"0.25rem\",\"defaultChroma\":\"45\",\"backgroundOpacity\":\"40%\",\"markBackground\":\"var(--sl-rapide-ec-marker-bg-color)\",\"markBorderColor\":\"var(--sl-rapide-ec-marker-border-color)\"},\"borderColor\":\"var(--sl-rapide-ui-border-color)\",\"frames\":{\"editorActiveTabIndicatorTopColor\":\"unset\",\"editorActiveTabIndicatorBottomColor\":\"var(--sl-color-gray-3)\",\"editorTabBarBorderBottomColor\":\"var(--sl-rapide-ui-border-color)\",\"frameBoxShadowCssValue\":\"unset\"}},\"plugins\":[{\"name\":\"Starlight Plugin\",\"hooks\":{}},{\"name\":\"astro-expressive-code\",\"hooks\":{}}]}]],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true,\"allowedDomains\":[]},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"staticImportMetaEnv\":false,\"chromeDevtoolsWorkspace\":false,\"failOnPrerenderConflict\":false},\"legacy\":{\"collections\":false},\"prefetch\":{\"prefetchAll\":true},\"i18n\":{\"defaultLocale\":\"en\",\"locales\":[\"en\"],\"routing\":{\"prefixDefaultLocale\":false,\"redirectToDefaultLocale\":false,\"fallbackType\":\"redirect\"}}}","docs",["Map",11,12,24,25,34,35,44,45,54,55,64,65,74,75,84,85,94,95,104,105,114,115,124,125,134,135,144,145,154,155,164,165,174,175,184,185,194,195,204,205,214,215,224,225,234,235,244,245,254,255,293,294,324,325,334,335,344,345,354,355],"about",{"id":11,"data":13,"body":21,"filePath":22,"digest":23,"deferredRender":15},{"title":14,"editUrl":15,"head":16,"template":17,"sidebar":18,"pagefind":15,"draft":19},"About",true,[],"doc",{"hidden":19,"attrs":20},false,{},"import ContactLink from \"../../components/ContactLink\";\n\n### Hello, Welcome to Ssaong 👋🏻\n\n안녕하세요, 부족함에 좌절하기보다 나아가는 프론트엔드 개발자 이예슬입니다.\n\n\u003CContactLink\n  client:load\n  type=\"github\"\n  url=\"https://github.com/yeaseul7\"\n  label=\"Github\"\n/>\n\n\u003CContactLink\n  client:load\n  type=\"email\"\n  url=\"mailto:cutie32769@gmail.com\"\n  label=\"Email\"\n/>\n\n\u003CContactLink\n  client:load\n  type=\"web\"\n  url=\"https://yeaseul7.github.io/about/\"\n  label=\"Web\"\n/>\n\n### INTRODUCE\n\n웹/앱 서비스 개발로 프론트엔드 개발을 담당하고 있는 이예슬입니다. React, Typescript, Next.js 등을 주력으로 사용하며 컴포넌트 기반 설계로\n서비스의 확장성과 유지보수성이 높은 아키택쳐를 설계합니다. CRM 개발을 하면서 복잡한 비즈니스 로직을 Custom Hook으로 분리/추상화하여 시스템의 안정성과 렌더링 성능을 동시에 확보했습니다.\n\n사용자가 자연스럽게 스며드는 서비스를 만들고자 합니다.\n개발자가 비즈니스 로직을 명확히 파악할 때 더 나은 문제 해결 방법과 사용자 경험 설계가 가능하다고 생각합니다.\n비즈니스와 기술을 잇는 통찰력을 위해 팀과 적극적으로 소통하며 함께 나아가겠습니다.\n\n### Skill\n\n- TypeScript\n- HTML/CSS\n- Next.js\n- React.js\n- node.js\n\n### Career\n\n#### 퀄리소프트 (2023.04 ~ 현재) | CRM Developer Team\n\n##### 1. CRM을 활용한 DX 개선\n\n- SAP ERP와 CRM 간의 데이터 정합성을 확보하기 위해 Node.js 기반의 Proxy API 동기화 프로세스를 구축하였습니다.\n- 기존 엑셀의 수기 관리 방식을 React 기반 웹 시스템으로 전환하여 업무 효율성을 높이는 UI/UX를 개발하였습니다.\n- 복잡한 실적 및 매출 관련 로직을 Custom Hook으로 모듈화하여 연산 과정의 예외 케이스와 프론트엔드 오류를 방지하였습니다.\n- 팀 내 TypeScript 설정(tsconfig) 표준화를 주도하고 ESLint/Prettier 도입으로 코드 컨벤션을 통합하여 유지보수성을 향상시켰습니다.\n\n\u003Csmall> React, TypeScript, .NET, IIS \u003C/small>\n\n##### 2. 사내 휴가 관리 시스템 구축\n\n수기 결재 방식의 불편함과 비효율을 해결하기 위해 기획부터 개발까지 전 과정을 주도하였습니다.\n\n- Vue.js를 활용하여 팀원 휴가 현황을 직관적으로 파악할 수 있는 대시보드 및 커스텀 캘린더를 개발하였습니다.\n- Microsoft Teams Webhook을 연동하여 휴가 신청 및 승인/반려 알림이 실시간으로 처리되는 자동화 프로세스를 구축하였습니다.\n\n\u003Csmall> Vue.js, Microsoft Teams Webhook, Power Automate \u003C/small>\n\n##### 3. SharePoint 연동 첨부파일 관리 시스템 구축\n\n- SharePoint REST API를 래핑한 첨부파일 관리 전용 Proxy 서버를 개발하였습니다.\n- 기업 내 기존 인프라인 SharePoint를 활용하여 공정 단계별 파일 업로드/다운로드 시스템을 구축하였습니다.\n- 파일 드래그 앤 드롭(DnD), 다중 파일 업로드, 진행률(Progress) 시각화 등 사용자 편의성을 고려한 UI를 구현하였습니다.\n\n\u003Csmall> React, Node.js, SharePoint REST API \u003C/small>\n\n### InternShip\n\n대학생일때 학업과 병행했던 인턴십입니다.\n\n##### To-infinity (23.12 ~ 24.03)\n\nFrontend\n\n- Folaio 디자인 시스템 구축\n- Folaio Flutter 기반 앱 출시\n- 온라인 실시간 과외 서비스 어드민 개발\n\n### Experience\n\n개인 프로젝트 개발 및 활동\n\n#### 꼬순내\n\n반려동물 커뮤니티 사이트\n\n- Firebase Authentication을 연동하여 Google 소셜 로그인 및 사용자 세션 관리 기능을 구현하였습니다.\n- Firestore NoSQL DB를 설계하여 CRUD 데이터를 효율적으로 관리하였습니다.\n- 계층형 데이터 구조를 활용하여 댓글과 대댓글 기능을 구현했고 users테이블로 사용자를 관리함으로 실시간 프로필 조회로 사용자 간의 상호작용을 강화하였습니다.\n- Cloudinary API와 이미지 최적화 함수를 생성하여 빠른 로드 및 이미지 최적화를 실행하였습니다.","src/content/docs/about.mdx","87e7056c9990867d","cs/cdn",{"id":24,"data":26,"body":31,"filePath":32,"digest":33,"deferredRender":15},{"title":27,"editUrl":15,"head":28,"template":17,"sidebar":29,"pagefind":15,"draft":19},"CDN",[],{"hidden":19,"attrs":30},{},"### CDN이란?\n\nCDN은 Content Delivery Network의 약자이다.\n웹 사이트에 접속할 경우 인터넷을 통해 사이트의 데이터가 사용자 컴퓨터로 이동하는데\n이 시간을 단축시키기 위해 CDN이 존재한다.\n따라서 CDN은 웹 페이지 로드 속도를 높이는 콘텐츠 전송 네트워크이다.\n\n웹사이트를 접속할 때 우리가 눈으로 보는 데이터들은 물리적으로 매우 먼 거리를 이동한다.\n이를 위해 CDN이 필요한데, CDN은 클라이언트와 웹사이트 서버 사이에 중간 서버를 둔다.\n이렇게 CDN 서버가 클라이언트(사용자 컴퓨터)와 서버(데이터가 존재하는)사이를 관리하며 트래픽을 줄이고, 대역폭 소비를 줄이면서 사용자 환경을 개선한다.\n\n### CDN이 전송하는 콘텐츠\n\n두가지 유형이 존재한다.\n\n1. **정적 콘텐츠**\n   이 콘텐츠는 사이트에서 주로 바뀌지 않는 부분이다.\n   mdn으로 예시를 들면 헤더 이미지, 로고, 배너가 된다. 이는 바뀌지 않는 값으로 수정할 필요가 없기 때문에 CDN에 저장하는게 이상적이다.\n2. **동적 콘텐츠**\n   날씨, 로그인 상태 같이 자주 바뀔 수 있는 부분이다.\n   또한 사용자별로 다르게 나타나야 하는 부분일 수 있다. 이것도 CDN을 통해 전송할 수 있는 콘텐츠 중에 하나다.\n\n### CDN 동작 원리\n\nCDN은 POP(여러 지리적 위치에 접속 지점) 또는 CDN 엣지 서버 그룹을 설정하는 방식으로 작동된다. 지리적으로 분산된 이 네트워크는 캐싱, 동적 가속 및 엣지 로직 계산의 원리를 기반으로 작동한다.\n위의 말만 봐서는 감이 잘 안온다.\n\n**먼저 CDN이 캐싱으로 작동한다고 했는데 무슨 의미일까?**\n먼저 컴퓨터에서 말하는 캐싱이 무엇인지 이해할 필요가 있다.\n컴퓨터에서 말하는 캐싱은 복사본은 저장하는 과정이라고 이해하면 된다.\n\n한국에서 중국에 서버가 존재하는 사이트에 방문할 때\n한국에서 사용자가 이용하는 컴퓨터와 중국에 있는 서버와 통신이 필요하다는 가정을 두자.\n\n사용자의 컴퓨터를 Client라고 칭하겠다.\n중국에 있는 서버를 Origin Server라고 칭하겠다.\n\n1. Client는 중국 서버에 먼저 콘텐츠(정적, 동적)를 요청한다.\n2. 해당 요청은 Origin Server에 도달한다.\n3. Origin Server는 Client에게 응답을 보내면서 Client와 지리적으로 가까운 CDN POP에 응답하는 내용의 복사본을 보낸다.\n4. CDN POP은 복사본을 캐싱된 파일로 **저장**한다.\n5. 이후에 Client가 같은 요청을 보내면 Origin Server까지 가지 않고 CDN POP의 캐싱된 서버에서 응답을 보낸다.\n\n위의 경우에는 정적 콘텐츠를 주고 받을 경우 유용할 것이다.\n\n**CDN이 동적 가속을 이용하는 것은 무슨 의미일까?**\n\n이는 CDN과 Origin Server의 연결의 최적화 해서 캐싱을 이용하기 어려운 동적 콘텐츠를 전달할 때 응답 시간을 단축시키는 것이다.\n\n만약 Client가 직접 Origin Server에 동적 요청을 보내는 경우 네트워크 지연 시간으로 요청이 제대로 가지 않거나 보안 검증 절차에 따라 오래걸릴 수 있다. 하지만 근처 CDN을 이용하면 보안 설정이 이미 되어있거나 지속적인 연결이 원활하게 될 수 있도록 설정되어있을 것이다.\n따라서 해당 시간을 단축시킬 수 있다.\n\n이는 **지능형 라우팅 알고리즘**을 사용하는데 이에 관해서는 이후에 포스팅 하겠다.\n\n**마지막으로 CDN 엣지 로직 계산은 무슨 의미일까?**\n\n클라이언트와 서버 간의 통신을 단순화하는 논리적 계산을 수행하도록 CDN 엣지 서버를 프로그래밍할 수 있다.\n예를 들면\n\n1. 사용자 요청을 검사하고 캐싱을 수정한다. (요청에 따라서 캐싱의 방식 결정)\n2. 잘못된 사용자 요청을 처리\n3. 응답하기 전에 콘텐츠 최적화\n\n## CDN의 예시\n\n- Amazon CloudFront\n- Azure Front Door\n\n내가 아는 예시는 여기까지 이다.\nCDN을 사용하면 Ddos 공격으로 부터도 어느정도 보호될 수 있다.","src/content/docs/cs/cdn.mdx","e3f06e593c77d0e9","index",{"id":34,"data":36,"body":41,"filePath":42,"digest":43,"deferredRender":15},{"title":37,"editUrl":15,"head":38,"template":17,"sidebar":39,"pagefind":15,"draft":19},"쎄옹의 개발 블로그",[],{"hidden":19,"attrs":40},{},"~~티스토리, 벨로그, ghpages를 거쳐 정착할 블로그~~\n\nFrontend 개발자 입니다.\n2023.11~\n\n졸업 성공회대\n2025.08~\n\nMac 기반입니다.\n\n오타, 보완할 내용 지적 환영합니다.","src/content/docs/index.mdx","76d4014569ec8745","js/higher-order-function",{"id":44,"data":46,"body":51,"filePath":52,"digest":53,"deferredRender":15},{"title":47,"editUrl":15,"head":48,"template":17,"sidebar":49,"pagefind":15,"draft":19},"고차함수",[],{"hidden":19,"attrs":50},{},"> Javascript는 함수형 프로그래밍이다.\n\n### 함수형 프로그래밍이란?\n\n단순하게 프로그래밍 패러다임 중 하나로, 불변성을 강조하며 프로그램의 상태 변경을 최소화 하는 것을 목표로 한 것이다.\n개념 자체는 수학적 함수의 개념에 기반을 두고 있다.\n불변성과 상태 변경을 최소화 한다는 것은 예측 가능성을 더 높여주는 것이라고 볼 수 있다.\n\n### Javascript에서 함수\n\njavascript에서 `함수는 일급 객체` 이다.\n일반 객체와는 다르다.\n**일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.**\n\n```jsx\nconst obj = { name: \"Dog\" };\nobj(); // ❌ TypeError: obj is not a function\n```\n\n```jsx\nfunction greet() {\n  return \"Hello!\";\n}\n\nconsole.log(greet()); // ✅ \"Hello!\"\n```\n\n#### 일급 객체랑 일반 객체는 다른건가?\n\n> 다르다.\n\n일급 객체의 특징을 일반 객체는 모두 포함하고 있지 않다.\n관계를 표현하면 아래와 같다.\n\n```jsx\n일반 객체(Object) ⊆ 일급 객체 ⊆ 함수(Function)\n```\n\n### 일급객체\n\n1.  무명의 리터럴로 생성할 수 있다. (런타임에 생성이 가능하다.)\n    익명 함수로 생성이 가능하다는 의미이다.\n    익명 함수의 형태를 보면 런타임(할당 단계)에 생성되는 변수에 저장 하는 형태이기 때문이다.\n\n    ````jsx\n    const add = function (a, b) {\n    return a + b;\n    };\n\n        console.log(add(2, 3)); // ✅ 5\n        ```\n\n    ````\n\n2.  변수나 자료구조(배열, 객체)에 저장할 수 있다.\n    변수에 저장되는 형태는 위의 예시와 같다.\n\n    ````jsx\n    const increase = function (num) {\n    return ++num;\n    };\n    const decrease = function (num) {\n    return --num;\n    };\n\n        const predicates = { increase, decrease };\n        ```\n\n    ````\n\n3.  함수의 매개변수에 전달할 수 있다.\n\n    ```jsx\n    function plusFunc(increaseFunc) {\n      let num = 0;\n      let result = increaseFunc(num);\n\n      return result;\n    }\n\n    // 위에서 predicates객체에 저장된 함수인 'increase'를 새로 생성한 plusFunc의 매개변수에 전달했다.\n    const calculated = plusFunc(predicates.increase);\n\n    console.log(calculated); // ✅ 1\n    ```\n\n4.  함수의 반환값으로 사용할 수 있다.\n\n    ```jsx\n    function applyOperation(operation, num) {\n      return operation(num);\n    }\n\n    console.log(applyOperation(predicates.increase, 5)); // ✅ 6\n    console.log(applyOperation(predicates.decrease, 5)); // ✅ 4\n    ```\n\n    ⚠️ 실제로 위의 코드에서 `applyOperation가 api를 사용해서 return을 얻을 경우` Promise 객체를 반환하여 예상하지 못한 동작을 할 수 있다.\n\n    그래서 이럴 경우 `async/await` 를 활용해서 Promise가 해결된 값을 반환하도록 수정해야한다.\n\n### 함수의 프로토타입 간략하게 보기\n\n일반 객체는 기본적으로 프로퍼티를 가질 수 있다.\n따라서 객체의 상속체계에 대한 정보를 가진 `__proto__` 가 존재하는데,\n함수는 Object.prototype을 상속받는게 아닌 Function.prototype을 상속받는다.\n\n추가로 `__proto__` 와 prototype의 차이에 대해 이해할 필요가 있다.\n\n### 고차 함수(Higher order Function)\n\n> 함수를 인자로 전달 받거나 함수를 결과로 반환하는 함수이다.\n\n> 🔖 “A closure is the combination of a function and the lexical environment within which that function was declared.”\n\n클로저는 함수와 그 함수가 선언됐을 때의 렉시컬 환경(Lexical environment)과의 조합이다.","src/content/docs/js/higher-order-function.mdx","5287ec700ffad5c8","js/closure",{"id":54,"data":56,"body":61,"filePath":62,"digest":63,"deferredRender":15},{"title":57,"editUrl":15,"head":58,"template":17,"sidebar":59,"pagefind":15,"draft":19},"closure",[],{"hidden":19,"attrs":60},{},"import { Image } from \"astro:assets\";\nimport closure1 from \"../../../assets/images/closure/closure_1.png\";\nimport closure2 from \"../../../assets/images/closure/closure_2.png\";\n\n#### 🔖 Closure는함수형 프로그래밍 언어에 등장한다.\n\nMDN의 Closure 정의\n\n> “A closure is the combination of a function and the lexical environment within which that function was declared.”\n\n> 클로저는 함수와 그 함수가 선언된 환경정보의 조합이다.\n\n## Closure\n\n외부함수보다 중첩함수가 더 오래 유지되는 경우 (생명주기가 종료된 외부함수의 변수를 중첩함수 내부에서 참조하는 현상)\n\n원래는 함수가 리턴하면 함수 내의 변수들은 GC에 의해 사라진다.\n\n```jsx\nconst x = 1;\n\nfunction outer() {\n  const x = 10;\n  const inner = function () {\n    console.log(x);\n  };\n  return inner;\n}\n\nconst innerFunc = outer();\n\ninnerFunc(); //✅ 10\n```\n\nouter가 inner를 반환한 시점에서 outer의 LifeCycle은 끝이 났다.\n하지만 innerFunc은 outer안에 있는 지역변수 x의 값을 찍고 있다.\n\n\"x는 private 변수이다 -> closure로 priovate 변수를 만들 수 있다.\"\n\ninner함수가 평가될 때 inner 함수의 환경에는 상위 스코프에 대한 정보가 있을 것이다.\nouter 함수는 평가될 때 전역 스코프를 함수의 환경 정보에 저장하고 있을 것이다.\n\n\u003CImage\n  src={closure1}\n  alt=\"closure_1\"\n  widths={[500, 1000]}\n  sizes=\"(max-width: 640px) 100vw, 500px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\nouter 함수가 return 하면 해당 실행 컨텍스트는 제거되고 생명주기도 끝나지만\nouter의 렉시컬 환경은 내부 슬롯에 저장되어있다.\n\n\u003Cb>\n  그러면 해당 변수는 닿을 수 있는 오브젝트가 되는것이다. -> GC의 대상 === 닿을\n  수 없는 오브젝트\n\u003C/b>\n\ninner 함수가 외부 렉시컬 환경을 outer 함수로 참조하고 있기 때문에 GC가 함부로 가져가지 않는다.\n이러한 현상을 클로저라고 한다.\n\n\u003CImage\n  src={closure2}\n  alt=\"closure_2\"\n  widths={[500, 1000]}\n  sizes=\"(max-width: 640px) 100vw, 500px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\ninner 함수를 반환 받은 innerFunc에 의해 inner 함수가 더 오래 생존하게 된 것이다.\n즉 inner 함수의 외부 렉시컬 환경에 outer의 x가 들어있기 때문에 innerFunc에서 10이 나오는 것이다.\n\n상위 스코프의 어떤 식별자도 참조하지 않는 경우 대부분의 모던 브라우저는 최적화를 통해 상위 스코프를 기억하지 않는다. 따라서 Closure라고 말할 수 없다.\n\n```javascript\nfunction outer() {\n  let hidden = 123;\n  return function inner() {\n    return 42; // hidden을 사용하지 않음\n  };\n}\n\nconst fn = outer();\nconsole.log(fn()); // 42\n```\n\n이게 예시인데 브라우저에 따라 최적화에 실패할 경우 메모리 누수가 발생할 수 있다.\nClosure를 사용하고 나서도 메모리 누수가 발생할 수 있기 때문에 후처리가 필요하다.\n\n```javascript\nfunction outer() {\n  const state = { x: 10 };\n  const inner = function () {\n    console.log(state.x);\n  };\n  inner.clear = function () {\n    state.x = null; // 내부에서 접근 가능\n  };\n  return inner;\n}\n\nconst innerFunc = outer();\ninnerFunc(); // 10\ninnerFunc.clear(); // x를 null로 설정\ninnerFunc(); // null\n```","src/content/docs/js/closure.mdx","b3262e3631d24d93","js/prototype",{"id":64,"data":66,"body":71,"filePath":72,"digest":73,"deferredRender":15},{"title":67,"editUrl":15,"head":68,"template":17,"sidebar":69,"pagefind":15,"draft":19},"Prototype",[],{"hidden":19,"attrs":70},{},"import { Image } from \"astro:assets\";\nimport constructorPrototypeImg from \"../../../assets/images/prototype/contructorprototype.png\";\n\n### 개요\n\nJavascript는 prototype 기반 OOP 언어라고 한다.\nJavascript를 계속 보니까 이제 실제로 어떤걸 가지고 prototype과 chain을 이야기 하는 것인지 조금은 이해했지만\n더 자세히 살펴볼 필요가 있을 것 같아 해당 글을 작성한다.\n\n### 📍 Prototype 기반 OOP\n\n> prototype은 Object들이 서로 속성을 공유하기 위해 사용하는 연결고리다.\n\n보통은 class로 상속모델을 사용하는데 javascript는 프로토타입 상속모델을 사용한다.\n객체가 상위 프로토타입 메소드와 속성을 상속받을 수 있는데 상위의 상위 프로토타입도 상속을 받을 수 있게 하는 것을 \u003Cb>Prototype Chain\u003C/b>이라고도 한다.\n즉, 상속되는 속성과 메소드는 생성자의 prototype안에 정의되어있다.\n\n```javascript\nlet a = {}\nconsole.log(a.__proto__)\n{__defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, __lookupSetter__: ƒ, …}\nconstructor:ƒ Object()\nhasOwnProperty:ƒ hasOwnProperty()\nisPrototypeOf:ƒ isPrototypeOf()\npropertyIsEnumerable:ƒ propertyIsEnumerable()\ntoLocaleString:ƒ toLocaleString()\ntoString:ƒ toString()\nvalueOf:ƒ valueOf()\n__defineGetter__:ƒ __defineGetter__()\n...\n```\n\n### ❤️ Prototype이란?\n\nprototype 객체는 생성자 함수로 생성된 객체들이 공통으로 사용할 수 있는 프로퍼티를 제공하는 역할을 합니다.\n일반 함수가 생성될 때 prototype 프로퍼티가 자동으로 함께 만들어집니다.\n\n#### 🔍 [[Prototype]] 내부 슬롯 vs prototype 프로퍼티\n\nJavaScript에서는 두 가지 다른 개념을 구분해야 합니다\n\n**`[[Prototype]]` 내부 슬롯**\n\n- 모든 객체가 가지고 있는 내부 슬롯\n- 상속을 구현하는데 사용되는 참조값\n- `__proto__` 접근자나 `Object.getPrototypeOf()`로 접근 가능\n- 객체의 `[[Prototype]]`은 상속 체인에서 상위에 있는 프로토타입 객체를 가리킵니다\n- 함수의 경우에는 `Function.prototype` 객체를 가리킵니다\n- 인스턴스의 경우에는 생성자 함수의 `prototype` 프로퍼티가 가리키는 객체를 가리킵니다\n\n**`prototype` 프로퍼티**\n\n- 함수 객체만 가지고 있는 일반 프로퍼티\n- 생성자 함수로 인스턴스를 만들 때 인스턴스의 `[[Prototype]]`이 가리킬 객체\n\n```javascript\nfunction Dog(name) {\n  this.name = \"early\"; // 생성자 함수의 프로퍼티 설정\n}\n\nconst puppy = new Dog(\"access\"); // Dog 생성자로 인스턴스 생성\n\n// prototype 프로퍼티 (함수만 소유)\nconsole.log(Dog.prototype); // 👉 Dog는 함수이므로 prototype 프로퍼티 존재 ✅\nconsole.log(puppy.prototype); // 👉 puppy는 인스턴스이므로 prototype 프로퍼티 없음 ❌ (undefined)\n\n// [[Prototype]] 내부 슬롯 (모든 객체가 소유)\nconsole.log(Dog.__proto__); // 👉 Function.prototype\nconsole.log(puppy.__proto__); // 👉 Dog.prototype (생성자의 prototype 프로퍼티와 연결)\n```\n\nPrototype값에 접근하기 위해서 `Object.prototype.__proto__`를 사용하면 된다.\n이렇게 하면 내부에서 Object.getPrototypeOf()가 호출된다.\n\n```javascript\nlet a = {}; // 빈 객체 생성\na.__proto__; // 객체의 프로토타입에 접근 (Object.prototype과 동일)\n```\n\n### ✅ constructor 프로퍼티\n\n프로토타입 객체(.prototype)는 constructor 프로퍼티를 갖는다.\n이 constructor프로퍼티는 객체의 입장에서 자신을 생성한 객체를 가리킨다.\n\n\u003CImage\n  src={constructorPrototypeImg}\n  alt=\"constructor 프로퍼티와 prototype 관계\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n### ✅ Prototype Chain\n\n객체에서 프로퍼티나 메소드에 접근하려고 할 때 자신에게 해당 속성이 없으면 [[Prototype]]이 가리키는 링크를 따라 탐색한다.\n계속 올라가다가 null을 프로토타입으로 가지는 Object를 만나면 그때 프로퍼티 참조를 멈춘다.\n이러한 과정을 프로토타입 체인이라고 한다.\n\n```javascript\nconst early = {\n  type: \"Dog\",\n};\n\nconsole.log(early.hasOwnProperty(\"type\")); // -> true\n\n//early라는 객체는 hasOwnProperty라는 메소드를 가지고 있지 않는데 정상적으로 출력되었다.\n//이는 early라는 객체의 [[Prototype]]이 가리키는 링크인 Object.prototype의 hasOwnProperty를 호출하였기 때문이다.\n//Object.prototype.hasOwnProperty.call(early, \"type\")\n```\n\njavascript의 Reference Type은 모두 위와 같은 방식으로 동작한다. (ex. Array, Set, Object, Function)\nReference Type은 위의 프로토타입 체인을 통해 내장 메서드에 접근한다. (ex. Array.prototype.map())\n\n_javascript의 Prototype 속성을 이용해서 자료구조에 활용하는 예시를 추후에 추가하고자 한다._\n\n### 📍 프로토타입 체인이 생성되는 경우\n\n1. 객체 리터럴 방식\n2. 생성자 함수 방식\n3. Object.create()\n\n#### 객체 리터럴 방식\n\njavascript 엔진은 객체 리터럴로 생성하는 코드를 만나면 내부적으로 Object.create(Object.prototype)와 유사한 방식으로 객체를 생성한다.\nObject.create()는 함수 객체로 일반 객체와 다르게 prototype 프로퍼티가 있다.\n\n### ⚠️ 주의할 점\n\nPolyfill : 브라우저가 지원하지 않는 최신 기능을 기존의 내장 객체의 프로토타입에 추가하는 코드\n\n```javascript\nif (!Array.prototype.includes) {\n  Array.prototype.includes = function (value) {\n    return this.indexOf(value) !== -1;\n  };\n}\n```\n\nPonyfill : Polyfill과 비슷하지만 내장 객체를 직접 수정하지 않고 독립적인 함수로 제공하는 방법\n\n```javascript\nfunction includes(array, value) {\n  return array.indexOf(value) !== -1;\n}\n\nincludes([1, 2, 3], 2); // true\n```\n\n위의 두가지를 사용하는 경우가 아니라면 네이티브 프로토타입을 확장하면 캡슐화를 망친다.\n(Monkey Patching: 기존의 객체나 함수의 동작을 런타임에 직접 수정하거나 덮어쓰는 것)","src/content/docs/js/prototype.mdx","b7b48a267ad85d61","js/single-thread",{"id":74,"data":76,"body":81,"filePath":82,"digest":83,"deferredRender":15},{"title":77,"editUrl":15,"head":78,"template":17,"sidebar":79,"pagefind":15,"draft":19},"Single Thread & Bytecode",[],{"hidden":19,"attrs":80},{},"### 멀티스레딩의 시대\n\n\"최신 CPU 아키텍처는 멀티코어를 통한 병렬 처리가 표준이 되었습니다.\n자바스크립트는 싱글 스레드(Single Thread) 기반의 이벤트 루프 모델을 채택했습니다.\n\nMulti-threading은 Concurrency issue가 치명적으로 존재합니다.\n\n#### Concurrency Issue\n\n여러 스레드가 하나의 자원(메모리)을 동시에 쓰려고 할 때 치명적인 문제가 발생합니다.\n이를 **경쟁 상태(Race Condition)**라고 합니다.\n\n하나의 자원(메모리)을 쓰는 순서는 운영체제에 따라 달라집니다. 따라서 예측하기가 매우 힘듭니다.\n이로인해 타이밍 버그가 생길 수 있는데,\n이 버그는 평소에는 보이지 않다가 디버깅하는 순간 타이밍이 바뀌면서 사라지는 **'하이젠버그(Heisenbug)'** 입니다.\n\n#### 그래서 javascript는\n\njavascript는 Dom 조작이 주된 일입니다.\n만약 멀티스레드가 DOM을 조작하도록 허용한다면...?\n한 스레드는 특정 노드를 삭제하려 하고, 다른 스레드는 동시에 그 노드의 색상을 변경하려 할 수 있습니다.\n그러면 화면은 엉망...\n\n따라서 javascript는 싱글스레드를 선택했습니다.\n\n### 그럼에도 javascript가 빨라보이는 이유는?\n\n이벤트 루프 덕분입니다.\nV8엔진은 싱글스레드라서 한가지 일처리만 합니다.\n하지만 javascript가 실행되는 런타임 환경(브라우저, node.js)은 멀티스레드로 구성되어있습니다.\n\njavascript는 fetch, setTimeout..등의 처리는 Web Api에게 위임합니다.\n그리고 이 작업을 기다리지 않습니다. 따라서 Non blocking 됩니다.\n\nWeb api가 작업을 끝냈다면 결과를 javascript가 작업하는 도중에 넣을 수 없기 때문에\n곧바로 메인 스레드에 밀어 넣지 않고 **태스크 큐(Task Queue)**에 넣어 대기시킵니다.\n이를 **Callback Queue**라고 합니다.\n\n그리고 javascript에서 event Loop가 계속 돌면서 메인 스레드의 call stack과 Queue에 대기중인 작업이 있는지 확인합니다.\n스택이 완전히 비었을 때(메인 스레드가 놀고 있을 때), 비로소 큐에 있는 콜백 함수를 꺼내 Call Stack으로 올려 실행합니다.\n\n---\n\n### 참고 자료\n\n- [Javascript 동작원리 (Single thread, Event loop, Asynchronous)](https://medium.com/@vdongbin/javascript-%EC%9E%91%EB%8F%99%EC%9B%90%EB%A6%AC-single-thread-event-loop-asynchronous-e47e07b24d1c)\n\n- [개발자라면 누구나 ‘모르면서 아는 척’하는 주제 7가지](https://www.itworld.co.kr/article/4100724/%ea%b0%9c%eb%b0%9c%ec%9e%90%eb%9d%bc%eb%a9%b4-%eb%88%84%ea%b5%ac%eb%82%98-%eb%aa%a8%eb%a5%b4%eb%a9%b4%ec%84%9c-%ec%95%84%eb%8a%94-%ec%b2%99%ed%95%98%eb%8a%94-%ec%a3%bc%ec%a0%9c-7.html)\n\n그 외 말투는 재미나이를 사용하여 보완하였습니다.","src/content/docs/js/single-thread.mdx","81825fd99088d115","cs/recursive",{"id":84,"data":86,"body":91,"filePath":92,"digest":93,"deferredRender":15},{"title":87,"editUrl":15,"head":88,"template":17,"sidebar":89,"pagefind":15,"draft":19},"recursive function",[],{"hidden":19,"attrs":90},{},"## javascript로 재귀함수 구현하기\n\n### 재귀함수란?\n\n함수 안에 자기 자신을 다시 호출하는 함수\n\n**대표적 사용 예시**\n피보나치 수열 구현하기\n\n---\n\n### 프로그래머스를 통한 예시 보기\n\n문제. [구슬을 나누는 경우의 수](https://school.programmers.co.kr/learn/courses/30/lessons/120840)\n난이도. Lv0\n\n#### 문제 설명\n\n머쓱이는 구슬을 친구들에게 나누어주려고 합니다. 구슬은 모두 다르게 생겼습니다. 머쓱이가 갖고 있는 구슬의 개수 balls와 친구들에게 나누어 줄 구슬 개수 share이 매개변수로 주어질 때, balls개의 구슬 중 share개의 구슬을 고르는 가능한 모든 경우의 수를 return 하는 solution 함수를 완성해주세요.\n\n#### 제한사항\n\n1 ≤ balls ≤ 30\n1 ≤ share ≤ 30\n구슬을 고르는 순서는 고려하지 않습니다.\nshare ≤ balls\n\n#### Hint\n\n서로 다른 n개 중 m개를 뽑는 경우의 수 공식은 다음과 같습니다.\n\n![](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/54c8b2b9-f88c-4a09-8956-7560ff7ea918/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202022-08-01%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%204.37.53.png)\n\n---\n\n나의 풀이\n\n```javascript\nfunction solution(balls, share) {\n  return Math.round(\n    recursion(balls) / recursion(balls - share) / recursion(share)\n  );\n}\n\nfunction recursion(n) {\n  return n === 0 || n === 1 ? 1 : n * recursion(n - 1);\n}\n```\n\n여기서 재귀함수가 `recursion` 함수 인데\n`recursion` 안에서 `recursion` 자기 자신을 호출하고 있는 것을 알 수 있다.\n\n`(n === 0 || n === 1) ? 1 `이라는 종결점을 지어두고\n이외에 자기 자신을 계속해서 호출하게 한다.\n그러면 피보나치 수열 구현이 완료된다.\n\n재귀함수의 대표적인 예시가 피보나치 수열을 구현하는 것인데\n해당 문제가 연습하기에 좋아 보여서 가지고 왔다.","src/content/docs/cs/recursive.mdx","63b757b4f57e441d","js/hoisting",{"id":94,"data":96,"body":101,"filePath":102,"digest":103,"deferredRender":15},{"title":97,"editUrl":15,"head":98,"template":17,"sidebar":99,"pagefind":15,"draft":19},"Hoisting",[],{"hidden":19,"attrs":100},{},"import { Image } from \"astro:assets\";\nimport contextStackImg from \"../../../assets/images/hoisting/contextStack.png\";\nimport environmentImg from \"../../../assets/images/hoisting/environment.png\";\nimport lexicalImg from \"../../../assets/images/hoisting/lexical.png\";\nimport flow1Img from \"../../../assets/images/hoisting/flow1.png\";\nimport flow1_1Img from \"../../../assets/images/hoisting/flow1-1.png\";\nimport flow1_2Img from \"../../../assets/images/hoisting/flow1-2.png\";\nimport flow1_3Img from \"../../../assets/images/hoisting/flow1-3.png\";\n\n자바스크립트 코어를 공부하면서 호이스팅과 실행 컨텍스트에 대해서 공부했다.\n호이스팅은 너무 유명한 개념에다가 거의 기본 개념 같은 거지만 코어에서 빠지지 않고 나오는 것 같다.\n그래서 과거에 정리했던 것보다 더 자세히 정리하고자 추가했다.\n\n호스팅 하면 실행 컨텍스트에 대한 내용을 빼먹을 수 없는데\n호이스팅과 비교하면 매우 머리 아프고 복잡한 과정이다.🥲\n\n솔직히 한 번만 보고 이해할 수 있다면 당신은 대단한 사람입니다.\n\n이번 포스팅은 modern javascript 책을 적극 참고해서 작성하였다.\n\n---\n\n### 호이스팅이 무엇인가?\n\nHoisting이라는 언어는 끌어올리다는 의미이다.\n사실 실제로 끌어올린다는 의미는 아니고 끌어올리는 것 처럼 보이는거다.\n제대로 말하려면 메모리가 먼저 할당된다고 해야된다.\n\njs 엔진이 코드를 실행하기 전에 변수나 함수를 메모리에 저장하는데  \n이게 끌어올려서 저장하는 것처럼 보였나.. 그래서 **호이스팅**이라고 한다.\n\njs 엔진이라는 얘기가 나왔다.  \n그 엔진이 어떻게 하길래 변수나 함수만 쏙 쏙 메모리에 저장한다는 것일까?\n\n쉽게 말하면 javascript가 코드를 실행하기 전에 먼저 쭉 보면서 평가를 한다.  \n**'아 여기 x라는 변수 있고... add라는 함수 있고..'**  \n이런 식으로 말이다.\n\n그러면서 **여기 x 있다~ add 있다~ 얘네 저장될 공간 좀 미리 만들어줘~**\n이게 호이스팅이다.\n\nvar로 선언하거나 함수 선언문으로 만들어진 애들은  \n할당되기 전에 참조할 수 있는 상태가 된다. Reference Error가 나지 않는다.\n\n이때 변수 선언문이 var로 작성된 애들과 ES6 문법 이후에 let과 const로 선언된 애들은 **다르게 호이스팅된다.**  \n둘 다 코드를 평가하면서 메모리를 주는데 그 메모리 환경이 다르다.\n\nvar는 전역 객체로 저장되는 곳으​로 가고\nlet과 const는 선언만 되는 곳으로 간다.\n\n그래서 var나 함수 선언문으로 만들어진 애들은 Reference Error가 나지 않는 것이다.  \n반면 let과 const는 선언만 되었고 초기화는 안되었기 때문에 참조할 수 없는 상태이다.  \n따라서 Reference Error가 발생한다.\n\n함수 선언문이라는 말을 자주 사용했다.\n\n_함수 선언문과 함수 표현식은 다르다._\n\n```javascript\nconst a = function () {\n  //...\n};\n```\n\n이렇게 표현식은 변수만 호이스팅되고 함수 자체는 실행되지 않는다.  \n하지만\n\n```javascript\nfunction a() {\n  //...\n}\n```\n\n이렇게 선언문은 var와 같이 호이스팅되어 함수 자체를 실행 가능하게 한다.\n\n---\n\n호이스팅 하면 실행 컨텍스트가 빠질 수 없다.\n\n실행 컨텍스트를 이해하면 호이스팅에 대해 더 자세히 알 수 있다.\n\n#### 먼저 실행 컨텍스트가 무엇인가?\n\n코드를 실행하는데 필요한 환경을 제공하고 실행 결과를 관리하는 영역이다.  \n실행 흐름을 관리하는 역할이다.\n\n이렇게만 들으면 감이 잘 안 온다.😅  \n일단 실행 컨텍스트가 생기는 과정부터 이해해 보자\n\nECMA script가 소스를 먼저 구분하고 그에 맞게 실행 컨텍스트가 생긴다.\n\n1. 전역 코드 - 전역 실행 컨텍스트\n2. 함수 코드 - 함수 실행 컨텍스트\n3. Eval 코드 - Eval 실행 컨텍스트\n4. module 코드 - module 실행 컨텍스트\n\n위와 같이 구분하고 각 코드마다 실행 컨텍스트가 생성된다.\n\n코드들은 평가된 후에 실행 컨텍스트가 생성되고 소스코드가 실행된다.  \njs는 코드를 실행하기 전에 평가와 실행 컨텍스트 생성 과정을 통해 준비를 한다고 생각하면 된다.\n\n---\n\n**1. 전역 코드와 전역 실행 컨텍스트**\n전역 변수 등을 관리하기 위한 최상위의 전역 스코프를 생성하는데 이 스코프를 전역 실행 컨텍스트가 관리한다.  \n 해당 스코프의 전역 변수들은 전역 객체와 연결된다.\n\n이 과정은 전역 코드가 평가될 때 실행된다.\n\n**2. 함수 코드와 함수 실행 컨텍스트**\n지역 스코프를 생성하고 그 안의 지역 변수, 매개변수, arguments 객체를 관리한다.  \n지역 스코프는 전역 스코프에서 시작하는 스코프 체인의 하나로 연결된다.\n\n마찬가지로 함수 코드가 평가될 때 실행된다.\n\n**3. Eval 코드와 Eval 실행 컨텍스트**\nstrict mode에서 자신만의 독자적인 스코프를 생성하고 관리한다.\n\neval()은 js에서 문자열로 된 코드를 실행할 수 있는 함수이다.  \n일반적인 상황에서 eval은 아래와 같이 쓰인다.\n\n```javascript\nvar x = 10;\neval(\"var y = 20; console.log(x);\"); // 10 출력 -> 현재 스코프의 x에 '접근' 가능하다.\nconsole.log(typeof y); // \"number\"\n```\n\n하지만 strict 모드에서는\n\n```javascript\n\"use strict\";\n\nvar x = 10;\neval(\"var y = 20; console.log(x);\"); // 10 출력 x는 현재 스코프에서 참조 가능\nconsole.log(typeof y); //y는 독립된 스코프에 존재하기 때문에 'undefined'출력\n```\n\n이렇게 독자적인 스코프를 가질 수 있다는 의미이다.\n\n**4. module 코드와 module 실행 컨텍스트**\n모듈별로 독자적인 스코프를 생성하고 관리한다.\n\nmodule 개념이 ES6 이후에 나온 개념이다.  \n모듈은 다른 모듈이나 전역 스코프와 독립적으로 동작한다.  \nimport export 키워드를 통해서 다른 모듈의 값에 접근할 수 있는 상황을 생각하면 편하다.\n\n---\n\n이렇게 생성된 실행 컨텍스트들은 선언문으로 생성된 변수나 함수를 해당 컨텍스트가 관리하는 스코프에 등록한다.  \n그 스코프는 Lexical Environment의 레코드이다.\n\nLexical Environment의 끝날 때쯤 설명하겠다.  \n그냥 이런 게 있구나 하고 넘어가자.🫠\n\n예시를 보면서 더 자세히 이해해 보자.\n\n```javascript\nconst x = 1;\nconst y = 2;\n\nfunction add(a) {\n  const x = 1;\n  const y = 2;\n  console.log(a + x + y);\n}\n\nadd(3);\n\nconsole.log(x + y);\n```\n\n이렇게 코드가 있으면 먼저 코드를 싹 돌면서 평가를 한다.  \n\"아.. 여기 x... y.. add 있구나.. 얘네 미리 메모리 공간 줘~\" 평가하면서 이 과정도 거친다.\n\n이걸 **호이스팅**이라고 했다.  \n호이스팅 과정에서 전역 객체에 프로퍼티와 메서드가 추가되는 것이다.  \n이게 **첫 번째 과정인 전역 코드 평가**이다.\n\n이후에 런타임이 시작된다. 코드를 실행하면서 변수에 값이 할당되거나 함수가 호출되는 것이다.  \n이때 함수를 만나면 \"전역 코드 실행 멈춰~나 add라는 함수 만났어\"를 한다.  \n이건 **두 번째 과정인 전역 코드 실행** 과정이다.\n\n전역 코드 실행을 멈추고 함수 코드가 평가되면서 지역 스코프에 변수들이 선언된다.  \n\"add라는 함수 안에 들어왔는데 여기 x 있고.. y 있고.. console.log도 있어~\"이런 식으로 말이다.  \n이때 arguments 객체가 생성되어 지역 스코프에 같이 등록되고 this 바인딩도 결정된다.  \n세 번째 과정인 **함수 코드 평가** 과정이다.\n\n이후에 코드가 실행되는 런타임이 시작된다. 함수 코드가 실행되면서 변수에 값이 할당되고 console을 찾아 log 함수도 실행한다.  \n\"add 안에 x한테 1 y한테 2 줘 그리고 console이라는 애가 어떤 앤지 찾아봐봐, 찾았어? 거기에 Log 있어? 아 함수야? 그거 실행시켜\" 이렇게 된다.  \n이건 네 번째 과정인 **함수 코드 실행 과정**이다.\n\n네 번째 과정에서 console을 찾는 방법을 간략하게 설명하자면  \nconsole이라는 애는 코드상에서 따로 정의되어 있는 게 보이지 않는다. 이건 전역 객체의 프로퍼티로 존재하는데  \n지역 스코프에서 어떻게 전역 객체의 프로퍼티로 접근하냐면  \n지역 스코프와 (전역 객체 프로퍼티가 존재하는) 전역 스코프는 스코프 체인으로 연결되어 있다.  \n그래서 참조를 따라가서 전역 스코프에서 찾아내는 것이다.\n\n예시를 통해 봤던 위의 과정을 실행 컨텍스트가 관리한다.\n그러면 초반에 설명했던  \n실행 컨텍스트는 \"코드를 실행하는데 필요한 환경을 제공하고 실행 결과를 관리하는 영역이다.  \n실행 흐름을 관리하는 역할이다.\"라고 했던 게 조금은 이해가 될 것이다.\n\n---\n\n조금만 더 깊게 살펴보자🤔  \n실행 컨텍스트는 위의 과정을 어떻게 실행하나?  \n실행 컨텍스트는 흐름은 실행 컨텍스트의 stack으로 식별자와 스코프는 Lexical environment로 관리한다.  \n그러면 위에서 잠깐 보고 넘어갔던 Lexical Environment가 실행 컨텍스트에서 식별자랑 스코프 관리하는 데에 쓰이는 것이라는 것을 알 수 있다.\n\n#### 실행 컨텍스트 스택\n\n예시 코드를 통해 살펴보자\n\n```javascript\nconst x = 1;\nconst y = 2;\n\nfunction add(a) {\n  const x = 1;\n  const y = 2;\n  function change() {\n    x = 3;\n    y = 4;\n    console.log(x + y);\n  }\n  change();\n}\n\nadd(3);\nconsole.log(x + y);\n```\n\n이런 코드가 있다.\n\n이때 스택 전체를 살펴보면\n\n\u003CImage\n  src={contextStackImg}\n  alt=\"실행 컨텍스트 스택\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n아까 위에서 예시로 계속 설명했던 실행 컨텍스트의 실행 과정과 함께 보면 이해가 '빡' 될 것이다.  \n이렇게 스택으로 관리하기 때문에  \n전역 실행 컨텍스트가 일을 멈추고 함수 실행 컨텍스트에서 일을 하고 다시 돌아오는 등의 과정이 있을 수 있는 것이다.\n\n---\n\n### Lexical Environment\n\n조금 어려울 수 있는 Lexical Environment에 대해서 살펴보자  \n간단하게 식별자와 그 값 그리고 상위 스코프에 대한 참조를 기록하는 자료구조이다.\n조금 더 간단하게는 **스코프와 식별자를 관리하는 저장소**이다.\n\n예시 코드로 보면 아래의 그림과 같이 해석할 수 있다.\n\n\u003CImage\n  src={environmentImg}\n  alt=\"Lexical Environment 예시\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n실행 컨텍스트마다 Lexical Environment가 존재하는데 전역 실행 컨텍스트에 선언되고 할당되는  \nx와 y 그리고 add 함수는 Global Lexical Environment에 저장된다.\n\n함수 실행 컨텍스트에 선언되어 있는 x와 y 그리고 change는  \nAdd 함수 Lexical Environment에 저장된다.  \n그리고 이 둘은 scope chain으로 연결된다.\n\n코드로 이해했으니 실제 실행 컨텍스트와 Lexical Environment가 어떻게 연결되어 있는지 보자.\n\n\u003CImage\n  src={lexicalImg}\n  alt=\"실행 컨텍스트와 Lexical Environment 연결\"\n  widths={[300, 600]}\n  sizes=\"(max-width: 640px) 100vw, 300px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n먼저 실행 컨텍스트는 Lexical Environment와 variavle Environment 두 가지의 Component로 구성된다.  \n생성 초기 두 컴포넌트는 같은 Lexical Environment를 참조한다.  \nLexical Environment은 식별자를 어디에서 참조할 것인지 등을 알려주는 곳이다.  \n하지만 variable 환경을 위한 새로운 Lexical Environment 환경이 새로 생기면 다른 곳을 참조하게 된다.  \n보통 var가 variable Environment Component에 저장된다.\n\n해당 **스코프의 식별자들을 등록하고 바인딩 된 값을 관리**하는 Lexical Environment Component는  \nEnvironmentRecord와 OuterLexicalEnvironmentReference로 구성되어 있다.\n\nEnvironmentRecord는 해당 스코프에 포함된 식별자를 등록하고 바인딩 된 값을 관리하는 저장소이고  \nOuterLexicalEnvironmentReference는 상위 스코프를 가리키며 상위 코드의 렉시 컬 환경을 가리키는 저장소라고 볼 수 있다.\n\n**따라서 Lexical Environment는 참조를 통한 Linked List Scope Chain를 구성한다.**\n\n---\n\n#### 실행 컨텍스트가 Lexical Environment를 통해 식별자를 어떻게 검색하는지 알아보자\n\n```javascript\nvar x = 1;\nconst y = 2;\n\nfunction test() {\n  //...\n}\n```\n\n이런 코드가 있을 때 아래의 과정을 거친다.\n\n\u003CImage\n  src={flow1Img}\n  alt=\"Lexical Environment 검색 과정\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n위에서 열심히 읽어도 이해가 안 가는 게 정상이다..\n\n차근차근 살펴보자\n\n\u003CImage\n  src={flow1_1Img}\n  alt=\"전역 실행 컨텍스트 생성 과정\"\n  widths={[300, 600]}\n  sizes=\"(max-width: 640px) 100vw, 300px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n컨텍스트 스택으로 잠시 올라가서 보자  \n맨 처음 실행 컨텍스트 스택에서 전역 실행 컨텍스트(Global Execution Context)가 푸시되는 것을 봤었다.\n그 과정이다.  \n그 전역 실행 컨텍스트가 전역 Lexical Environment를 생성한다.\n\nLexical Environment 가 어떻게 생겼는지를 다시 보고 와서 참고하기를 추천한다.\n\n\u003CImage\n  src={flow1_2Img}\n  alt=\"Global Lexical Environment 구성\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n위의 Global Lexical Environment는 GlobalEnvironmentRecord와 OuterLexicalEnvironmentReference로 구성되어 있는데 전역이기 때문에 OuterLexicalEnvironmentReference에는 null이 있을 것이다.\n\nGlobalEnvironmentRecord에는 어떤 것이 있냐면  \nvar 같이 전역 객체에 저장되는 것들이 존재하는 **Object Environment Record**와\nlet, const와 같이 호이스팅은 되지만 초기화는 안 되는 것들이 존재하는 **Declarative Environment Record**(선언적 환경 레코드)로 구성된다.\n\n호이스팅에서 let과 const는 선언만 된다고 했다.\n\n\u003CImage\n  src={flow1_3Img}\n  alt=\"Object Environment Record에 저장되는 과정\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n마지막으로 전역 객체에 저장된다고 했던 Object Environment Record에 들어가는 애들이 전역 객체에 저장이 된다.\n\n이런 식으로 실행 컨텍스트가 식별자를 관리한다.\n\n---\n\n여기까지 실행 컨텍스트와 Lexical Environment 그리고 호이스팅에 대해 살펴보았다.\n\nthis 바인딩 그리고 더 자세히 포스팅하고 싶었지만 더 살펴보고 포스팅하고 싶어 그 부분은 미룬다.\n\n많이 어렵기 때문에 계속 봐야 하는 개념이라고 생각한다.\n\n틀린 부분 댓글 남겨주면 매우 매우 감사합니다🤗\nhttps://blog.naver.com/neeko_k/223597163448","src/content/docs/js/hoisting.mdx","a897a78571a2bdc7","js/this",{"id":104,"data":106,"body":111,"filePath":112,"digest":113,"deferredRender":15},{"title":107,"editUrl":15,"head":108,"template":17,"sidebar":109,"pagefind":15,"draft":19},"this",[],{"hidden":19,"attrs":110},{},"import { Image } from \"astro:assets\";\nimport thisImg from \"../../../assets/images/this/this.png\";\n\n실행 컨텍스트를 공부하다가 this에 대한 얘기를 들었다.  \nthis는 javascript에서 논란이 많은? 친구이다.\n\n먼저 this가 무엇이냐?\n\n함수가 호출될 때 정해지는 함수 컨텍스트이다.  \n귀에 걸면 귀걸이 코에 걸면 코걸이 같은 것이다.😂\n\njavascript는 호출될 때\n인자, arguments 객체, this를 전달받는다.  \n이렇게 전달받을 때마다 어떤 걸 바인딩 하는지 결정한다.\n\n함수 컨텍스트, 실행 컨텍스트에 대해서는 [저번 포스팅](https://blog.naver.com/neeko_k)에서 다뤘다.  \n기본적으로 this는 전역 객체에 바인딩 된다.  \n이는 혼동을 야기할 수 있다.\n\n이게 무슨 말이야~\n싶겠지만 함수가 어떻게 호출되고 그에 따가 어떤 식으로 달라지는지 살펴보자.\n\n---\n\n### 함수 호출 방식\n\n함수 호출 방식은\n\n1. 일반 함수 호출\n2. 메서드 호출\n3. 생성자 함수 호출\n4. call, apply, bind 사용\n   이렇게 4가지가 있다.\n\n그러면 각각 자세히 어떻게 하는건지 알아보자\n\n#### 일반 함수 호출\n\n```javascript\n//일반 함수\nfunction add() {\n  //외부함수\n  console.log(\"add's this: \", this); // window , \"use strict\"에서는 undefined나옴\n  function add2() {\n    //내부함수\n    console.log(\"add2's this: \", this); // window , \"use strict\"에서는 undefined나옴\n  }\n  add2();\n}\nadd();\n\n//화살표 함수\nfunction add() {\n  // 외부 함수\n  console.log(\"add's this: \", this); // window (전역 모드) 또는 undefined (\"use strict\" 모드)\n\n  const add2 = () => {\n    // 내부 화살표 함수\n    console.log(\"add2's this: \", this); // add()의 this를 참조\n  };\n  add2();\n}\nadd();\n```\n\n일반 함수 호출에서 this는 다른 함수 안에 있는 내부 함수에서 전역 객체에 바인딩된다.\n이런 this의 전역 바인딩을 막기 위해서는 arrow function을 사용하는 방법이 있다.\n\narrow function은 es6에 나왔다.\n\narrow function의 this는 뭐가 다르다는 걸까?  \nes6에서 this는 **정의된 스코프(Lexical scope)**를 참조한다.  \n따라서 상위 환경의 this를 계승 받는다.\n\n즉 arrow function은 자신이 정의된 위치에서 this를 사용한다.\n\n#### 메서드 호출\n\n아래의 예시에서 add는 메서드 호출이고 add2는 함수 내부에서 정의된 일반함수이다.  \n따라서 독립적인 함수 호출이다.  \n하지만 위에서 설명했던 것처럼 화살표 함수를 사용하면 Lexical scope에 의해 상위 스코프를 참조하여 obj를 가리키게 할 수 있다.  \n또 다른 변수에 this를 할당해서 사용하는 방법도 있다.\n\n⚠️메서드를 화살표 함수로 정의하면 그 함수의 상위 스코프를 받기 때문에 전역 객체를 의미할 수 있다.  \n일반 함수로 작성하고 내부 함수를 화살표 함수로 작성하면 생각하는 대로 계승될 것이다.\n\n```javascript\nlet methodValue = 1;\n\nconst obj = {\n  value: 100,\n  add: function () {\n    //메서드\n    console.log(\"add's this: \", this); // obj\n    console.log(\"add's this.value: \", this.value); // 100\n\n    function add2() {\n      //내부함수\n      console.log(\"add2's this: \", this); // window\n      console.log(\"add2's this.value: \", this.value); // 1\n    }\n    add2();\n  },\n};\nobj.add();\n\n//화살표 함수 쓰는 버전\nlet methodValue = 1;\n\nconst obj = {\n  value: 100,\n  add: function () {\n    //메서드\n    console.log(\"add's this: \", this); // obj\n    console.log(\"add's this.value: \", this.value); // 100\n\n    const add2 = () => {\n      //화살표 함수\n      console.log(\"add2's this: \", this); // obj\n      console.log(\"add2's this.value: \", this.value); // 100\n    };\n    add2();\n  },\n};\n\nobj.add();\n\n//다른 변수에 this를 할당해서 사용하는 방법\n\nlet methodValue = 1;\n\nconst obj = {\n  value: 100,\n  add: function () {\n    const that = this;\n    //메서드\n    console.log(\"add's this: \", this); // obj\n    console.log(\"add's this.value: \", this.value); // 100\n\n    function add2() {\n      //내부함수\n      console.log(\"add2's that: \", that); // obj\n      console.log(\"add2's that.value: \", that.value); // 100    }\n    add2();\n  },\n};\nobj.add();\n```\n\n#### 생성자 함수 호출\n\njavascript에서는 new를 사용해서 생성자 함수를 만들고 호출할 수 있다.  \n생성자 함수에서 this는 프로퍼티를 상속한다.\n\n아래에서 생성자 함수를 만드는 방법과 동작 방법을 보여준다.\n\n```javascript\n// 생성자 함수는 대문자로 시작한다.\nfunction Person(name) {\n  this.name = name;\n}\n//prototype 객체로 메소드를 가질 수 있다.\nPerson.prototype.getName = function () {\n  return this.name;\n};\n\nlet me = new Person(\"Lee\");\n// this에 바인딩 될 객체는 me이다.\nconsole.log(me.getName()); //Lee\n\n//new를 붙이지 않을 경우 생성자 함수 아님\nlet you = Person(\"Park\");\nconsole.log(you); // undefined\n\nPerson.prototype.name = \"Kim\";\nconsole.log(Person.prototype.getName()); //Kim\n//이렇게 this의 속성을 변경할 수 있다.\n```\n\n위의 과정을 그림으로 그리면 아래와 같이 나타난다.\n\n\u003CImage\n  src={thisImg}\n  alt=\"생성자 함수와 this, prototype 관계\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n#### 생성자 함수 동작 방법 찍먹하기\n\n```javascript\n// 생성자 함수는 대문자로 시작한다.\nfunction Car(name) {\n  // 생성자 함수 코드 실행 전\n  // 생성할 빈 객체 생성 => \"복사본 만든대~ 빈 종이 가져와\"\n  // this가 빈 객체를 가리킴 => \"내용 여기에 넣으면 돼?\"\n  // 빈 객체 : Car의 프로퍼티가 가르키는 객체를 자신의 prototype 객체로 설정 => \"빈종이 : 나 이번 복사에 들어간다\"\n  this.type = name; // this를 통해 프로퍼티 및 메소드 추가 => \"복사중 ...\"\n  // this를 통해 생성자 함수가 생성할 인스턴스에 동적으로 프로퍼티를 생성하고 초기화\n  // 생성된 함수 반환\n}\n\nlet myCar = new Car(\"sm5\");\n// this가 가리키는 인스턴스를 반환\nconsole.log(myCar); // {type: \"sm5\"}\n```\n\n1. 생성자 함수 코드 실행 전 생성자 함수가 새로 생성할 객체인 빈 객체를 생성\n2. 그리고 생성자 함수 안에 있는 this가 이 빈 객체를 가리킴\n3. 빈 객체도 생성자 함수의 prototype 프로퍼티가 가리키는 객체를 자신의 prototype 객체로 설정\n4. 이후 생성된 빈 객체에 this를 통해 프로퍼티와 메서드 등을 추가한다.\n5. 마지막으로 생성된 객체를 반환한다.\n\n_이때 어떤 걸 반환하느냐에 따라 this 바인딩이 끊길 수도 있고 반환값이 무시될 수 있다._\n\n마지막에 생성된 객체를 반환하지 않으면\n예상과 다른 값이 출력될 수 있다.\n\n그 경우를 아래에 예시를 통해 설명한다.\n\n#### 생성자 함수가 다른 값을 반환하는 경우\n\n```javascript\n// 다른 객체를 반환하는 경우\nfunction ExceptionConstructor(name) {\n  // 생성자 함수 코드 실행 전\n  this.type = name;\n  // this를 통해 생성자 함수가 생성할 인스턴스에 동적으로 프로퍼티를 생성하고 초기화\n  // 다른 개체를 반환하면 this가 아닌 해당 객체가 반환\n  return { year: 2022 };\n}\n\nlet myCar2 = new ExceptionConstructor(\"sm5\");\nconsole.log(myCar2); // {year: 2022} 생성자 함수 역할을 못해서 this가 아닌 다른 객체 반환 prototype도 없음\n```\n\n```javascript\n//기본값을 반환하는 경우\nfunction ExceptionConstructor2(name) {\n  // 생성자 함수 코드 실행 전\n  this.type = name;\n  // this를 통해 생성자 함수가 생성할 인스턴스에 동적으로 프로퍼티를 생성하고 초기화\n  // 기본타입을 반환하면 this가 반환\n  return 42;\n}\nlet myCar3 = new ExceptionConstructor(\"sm5\");\nconsole.log(myCar2); // {type: \"sm5\"} 반환 값이 무시되고 this가 반환\n```\n\n#### call, apply, bind 사용\n\n이 방법은 명시적으로 this 바인딩 하는 방법이다.\n위에서는 this를 명시적으로 바인딩 하지 않았기 때문에 이런 작동 방식을 이해하기 전까지는 왜 저 값이 나오는지 모를 수 있다.\n이 함수들은 Function.prototype 객체의 메서드이다.\n\n**Function.prototype.apply, Function.prototype.call는 함수를 실행하지만  \nFunction.prototype.bind는 함수에 인자로 전달한 this가 바인딩 된 새로운 함수를 리턴하지 실행하지 않는다는 차이가 있다.**\n\n```javascript\nconst useThisMethodsValue = 1;\n\nconst useThisMethodsObj = {\n  value: 100,\n  add: function () {\n    const that = this;\n\n    console.log(\"add's this: \", that); // avoidGloabalObj\n    console.log(\"add's this.value: \", that.value); // 100\n\n    function add2(a, b) {\n      console.log(\"add2's this: \", this); // avoidGloabalObj\n      console.log(\"add2's this.value: \", this.value); // 100\n      console.log(\"add2's arguments: \", a, b); // 1, 2\n    }\n    add2.apply(useThisMethodsObj, [1, 2]);\n    add2.call(useThisMethodsObj, 1, 2);\n    add2.bind(useThisMethodsObj)(1, 2);\n  },\n};\nuseThisMethodsObj.add();\n```\n\n---\n\n### 마무리\n\n이렇게 함수를 호출하는 방식을 쭉 나열했다.\n\n그리고 그 안에서 this가 어떻게 바인딩 되는지 코드 예시를 통해 설명했다.\n\n한 번에 이해하기 복잡할 수 있다.\n\n이럴 땐 전역 객체를 한다고 하고 아닐 땐 또 다르다고 하고\n\n​\n\n내가 생각하기에 기본적으로 this는 전역 객체를 바인딩 하기 때문에 화살표 함수를 사용해서 상위 스코프를 참조하는 방식으로 예측 가능한 코드를 짜는 것이 좋아 보인다.\n\n다만 그 과정에서 주의해야 하는 부분도 있기 때문에 그 부분에 대해서도 다시 되짚어보기를 바란다.\n\n​","src/content/docs/js/this.mdx","d5f769e9e4e3bdb2","js/v8-bytecode",{"id":114,"data":116,"body":121,"filePath":122,"digest":123,"deferredRender":15},{"title":117,"editUrl":15,"head":118,"template":17,"sidebar":119,"pagefind":15,"draft":19},"V8 Bytecode",[],{"hidden":19,"attrs":120},{},"import { Image } from \"astro:assets\";\nimport jspipelineImg from \"../../../assets/images/v8bytecode/jspopeline.webp\";\nimport ldaSmiImg from \"../../../assets/images/v8bytecode/LdaSmi[1].webp\";\nimport starr0Img from \"../../../assets/images/v8bytecode/starr0.webp\";\nimport addr0Img from \"../../../assets/images/v8bytecode/addr0.webp\";\n\nv8 엔진은 javascript를 컴파일할 때 parser는 abstract syntax tree를 생성합니다.\n(이떄 구문트리는 javascript의 syntax를 트리형태로 만든 것)\n이후 interpreter인 Ignition는 syntax를 트리를 bytecode로 변환합니다.\n최적화 컴파일러 TurboFan는 최종적으로 bytecode를 가져와서 최적화된 기계어 코드를 생성합니다.\n\n\u003CImage\n  src={jspipelineImg}\n  alt=\"V8 엔진 JavaScript 파이프라인\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n이렇게 인터프리터와 컴파일러가 동시에 존재하는 이유는 시동시간과 시동속도의 트레이드오프를 해결하기 위한 JIT전략때문에 존재합니다.\nIgnition는 코드를 한 줄 한 줄 읽어서 바로 실행합니다.\n반면 TurboFan는 자주쓰이는 코드를 CPU에게 최적화된 기계어로 변환합니다.\nIgnition는 느리지만 해석할때 반복문이나 특정함수(Hot Spot)를 감지하면 TurboFan을 호출하여 최적화해서 실행합니다.\n\n```javascript\n//node.js에서 bytecode 뜯어보는 방법\nnode --print-bytecode --eval 1+1\n```\n\nbytecode에서 중요한것은 **Accumulator Register**입니다.\nbytecode는 javascript의 모든 기능을 구성하는 작업 요소입니다.\n\n```\nAdd(더하기), Typeof(타입)\nLdaNamedProperty, CreateObjectLiteral, SuspendGenerator...\n\n//bytecodes.h 참고\n```\n\nbytecode는 입력값과 출력값을 저장할 register를 필요로합니다.\nv8의 Ignition는 r0, r1과 같은 일반 레지스터와 **Accumulator Register**를 사용합니다.\n\nAccumulator Register는 `Add r1`같이 'r1과 어큐물레이터에 있는 값을 더해'를 짧게 적음으로 바이트 코드 길이를 줄이고 메모리를 절약할 수 있게 만듭니다.\n\n### 실행 예시\n\n```javascript\nfunction incrementX(obj) {\n  return 1 + obj.x;\n}\n\nincrementX({ x: 42 });\n```\n\n1. stackCheck : 스택 메모리가 충분한지 검사\n\n   \u003CImage\n     src={ldaSmiImg}\n     alt=\"LdaSmi [1] bytecode\"\n     widths={[400, 800]}\n     sizes=\"(max-width: 640px) 100vw, 400px\"\n     formats={[\"avif\", \"webp\"]}\n     quality={80}\n     loading=\"lazy\"\n     decoding=\"async\"\n   />\n\n2. LdaSmi [1] : Load accumulator Smi (Small Integer) (1을 어큐물레이터에 넣기)\n\n   \u003CImage\n     src={starr0Img}\n     alt=\"Star r0 bytecode\"\n     widths={[400, 800]}\n     sizes=\"(max-width: 640px) 100vw, 400px\"\n     formats={[\"avif\", \"webp\"]}\n     quality={80}\n     loading=\"lazy\"\n     decoding=\"async\"\n   />\n\n3. Star r0 : 어큐뮬레이터에 있는 값(1)을 레지스터 r0에 복사해서 저장\n\n```\n- length: 1\n           0: 0x2ddf8db91611 \u003CString[1]: x>\n```\n\n4. LdaNamedProperty a0, [0], [4] :(obj.x를 가져오기)\n   \u003CImage\n     src={addr0Img}\n     alt=\"Add r0 bytecode\"\n     widths={[400, 800]}\n     sizes=\"(max-width: 640px) 100vw, 400px\"\n     formats={[\"avif\", \"webp\"]}\n     quality={80}\n     loading=\"lazy\"\n     decoding=\"async\"\n   />\n5. Add r0, [6] : 더하기\n6. Return\n\n```\n$ node --print-bytecode incrementX.js\n\n[generating bytecode for function: incrementX]\nParameter count 2\nFrame size 8\n  12 E> 0x2ddf8802cf6e @    StackCheck\n  19 S> 0x2ddf8802cf6f @    LdaSmi [1]\n        0x2ddf8802cf71 @    Star r0\n  34 E> 0x2ddf8802cf73 @    LdaNamedProperty a0, [0], [4]\n  28 E> 0x2ddf8802cf77 @    Add r0, [6]\n  36 S> 0x2ddf8802cf7a @    Return\n```\n\n---\n\n#### 참고자료\n\n[Just In Time Compilation (JITC)](https://jewelism.github.io/js/)\n[Understanding V8’s Bytecode](https://medium.com/dailyjs/understanding-v8s-bytecode-317d46c94775)","src/content/docs/js/v8-bytecode.mdx","c1b3dd930e7ed755","fe/ssr-csr",{"id":124,"data":126,"body":131,"filePath":132,"digest":133,"deferredRender":15},{"title":127,"editUrl":15,"head":128,"template":17,"sidebar":129,"pagefind":15,"draft":19},"SSR & CSR",[],{"hidden":19,"attrs":130},{},"import { Image } from \"astro:assets\";\nimport ssrImg from \"../../../assets/images/ssr-csr/ssr.webp\";\nimport csrImg from \"../../../assets/images/ssr-csr/csr.webp\";\n\n\u003CImage\n  src={ssrImg}\n  alt=\"SSR 애플리케이션 형성 과정\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n### SSR application 형성 과정\n\nSSR 애플리케이션은 화면을 그릴 때 서버에 HTTP 요청으로 데이터를 받아와서 HTML 파일을 클라이언트로 전송한다.\n\nSSR서버와 클라이언트가 어느단계로 작동하는가?\n\n1. 브라우저가 특정 URL에 대해 HTML 파일을 SSR 서버로 요청한다.\n2. SSR 서버가 모든 요청받은 데이터를 가지고 HTML 파일을 반환한다.\n3. 클라이언트에서 유저가 볼 수 있는 페이지를 랜딩한다. [초기 로딩 상태로 표시]\n4. 클라이언트에서 VDOM을 붙이거나 이벤트들을 붙인다.(Hydration 과정)\n5. 사용할 수 있는 화면이 완성된다.\n\n### 내가 프로젝트에서 Next.js를 사용하는 이유\n\n나는 프로젝트를 할 때 보통 react를 사용한다.  \nreact가 생태계가 넓어서 학습하기에 좋다고 생각하기 때문이다.\n\n'에브리 멍멍'이라는 프로젝트를 진행 할 때 Next.js도 사용하게 되었다.  \nNext.js는 SSR과 SSG를 지원함으로 서버에서 랜더링 된 HTML이 검색 엔진 크롤러가 콘텐츠를 쉽게 읽을 수 있다.  \n또한 Next.js의 app router로 인해 페이지를 구성하는게 유리했다.  \n작업의 편리성과 SEO를 고려해 Next.js를 선택하게 되었다.\n\n\u003CImage\n  src={csrImg}\n  alt=\"CSR 애플리케이션 형성 과정\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n#### 그렇다면 SSR과 CSR의 차이점은 무엇일까?\n\n최초의 DOM tree가 어디서 생성되느냐에 따라 구분지었다고 볼 수 있다.\n\nCSR은 서버가 html파일을 가지고 오는것이 아니고 javascript 파일을 가지고 와서 화면을 그리는 방식인데  \n클라이언트가 빈 HTML에 서버에서 받아온 js파일을 이용해서 DOM tree를 형성하는 것이라고 볼 수 있다.  \n(그러면 초기 랜더링 속도가 아무래도 오래걸릴 것이다.)\n\n결론은 CSR은 클라이언트(브라우저)에서 DOM이 형성된다.\n\n반면 SSR은 서버에서 html 파일을 가지고 온다.  \n서버에서 html을 가지고 오기 때문에 서버에서 DOM이 형성된다고 볼 수 있다.\n\n### SEO와 SSR그리고 CSR\n\n위에서 SEO를 고려해서 Next.js를 선택했다고 했는데,  \nSEO를 위해서는 구글 봇이 나의 웹페이지를 잘 읽어야 한다.  \nCSR로 되어있으면 랜더링 하는 과정과 그걸 해석하는 시간이 필요하다.  \n그래서 더 복잡하고 시간이 걸릴 수 있다.  \n게다가 javascript를 해석하는데에 제한이 있어서 그 점을 고려해야한다.\n\n반면 SSR은 html이 미리 랜더링 되어있기 떄문에 크롤러가 해석하는데 시간도 단축되고 더 심플하다.\n\n_모든 경우에 SSR이 유리한 것은 아니다._  \nGoogle Bot의 크롤링 방식을 보다 잘 이해하고 어떤 것이 제한적이며 랜더링 최적화 과정을 거친다면 못지 않은 SEO를 구축할 수 있다.\n\n**SSR에서는 치명적인 단점이 존재한다.**  \n서버에서 html이 완성되어 전달되기 때문에 동적인 컨텐츠를 표시하기 힘들다.  \n때문에 클라이언트측에서 실행되는 js 파일을 추가해서 동적인 컨텐츠를 다룰 수 있다.\n\nNext.js에서 SSR와 CSR 개념을 결합해서 사용하는 Server-component, Client-compoenent 개념과 밀접한 관련이 있다.\n\n### SSR Hydration\n\n서버에서 html 파일을 완성된 형태로 가지고 오니까 초기 랜더링 속도가 SSR이 **무조건** 압도적으로 빠른건가?  \n**아니다**  \nSSR에서 완성된 Dom tree를 가지고 온다고 해도 동적인 콘텐츠를 가지기 위해서는 Hydration이라는 작업이 필요하다.  \n결국 이 모든 과정이 끝나야 페이지를 사용할 수 있다.\n\n제대로 비교하기 위해서는 초기 HTML에 내용이 어느정도 포함되어 있는지와 Hydration 과정이 얼마나 복잡한지 고려해야한다.\n\n사진 출처 : https://medium.com/@derekvogt3/csr-ssr-vs-ssg-87b112370db","src/content/docs/fe/ssr-csr.mdx","5db8ece8b83ca45b","fe/dunamic-meta",{"id":134,"data":136,"body":141,"filePath":142,"digest":143,"deferredRender":15},{"title":137,"editUrl":15,"head":138,"template":17,"sidebar":139,"pagefind":15,"draft":19},"동적 meta (Next)",[],{"hidden":19,"attrs":140},{},"import { Image } from \"astro:assets\";\nimport beforeImg from \"../../../assets/images/setSeo/before.png\";\n\n### 개요\n\n\u003CImage\n  src={beforeImg}\n  alt=\"기존 meta 태그 설정 전\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n기존에 어떤 페이지든 위처럼 보이던 방식을 페이지마다 사진과 글이 포함되면 그 내용을\n보여주도록 설정한다.\n\nstack: next.js, firebase\n\nuseParams에서 Id를 가져와서 firebase에서 검색 후 페이지 데이터를 가져온다.\n\n가져온 데이터로 metadata를 설정해야하는데 이때 metadata는 \"use client\"를 사용해선 안되고 서버에서 작업이 이루어져야한다.\n\n#### Why?\n\n검색엔진과 소셜미디어 Bot은 javascript를 실행하지 않고 HTML만 읽어간다.\n\nlink를 통해 meta데이터를 파악하고 보여줄 때 직접 홈페이지에 들어가서 javascript를 모두 실행하는것을 기다려주지 않는다.\n\"use client\"는 빈 HTML을 받고 javascript 번들을 다운 후 실행한다.\nSSR은 서버에서 데이서 fetching을 완료하고 metadata가 포함된 HTML을 생성해서 보낸다.\n따라서 봇이 바로 접속하자마자 tag나 meta data를 읽을 수 있다.\n\nOpen Graph의 경우\nURL에 get 요청을 보낸후 반환되는 head에 포함된 metadata를 긁는다.\n\n### How\n\n\"use client\"로 되어있는 부분을 client Component로 분리하고 page.tsx에서는 SSR 방식으로 진행했다.\n\n```\nimport { Metadata } from 'next';\nimport ReadPostContent from '@/packages/ui/components/home/read/ReadPostContent';\nimport { getPostById } from '@/lib/api/post';\n\nfunction extractText(html: string | undefined): string {\n  if (!html) return '';\n  return html\n    .replace(/\u003C[^>]*>/g, '')\n    .replace(/\\s+/g, ' ')\n    .trim();\n}\n\nfunction extractFirstImage(html: string | undefined): string | null {\n  if (!html || typeof html !== 'string') {\n    return null;\n  }\n  const imgRegex = /\u003Cimg[^>]+src=[\"']([^\"']+)[\"'][^>]*>/i;\n  const match = html.match(imgRegex);\n  return match && match[1] ? match[1] : null;\n}\n\nexport async function generateMetadata({\n  params,\n}: {\n  params: Promise\u003C{ id: string }>;\n}): Promise\u003CMetadata> {\n  const { id: postId } = await params;\n\n  const baseUrl =\n    process.env.NEXT_PUBLIC_SITE_URL ||\n    (process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : null) ||\n    'http://localhost:3001';\n\n  try {\n    const post = await getPostById(postId);\n\n    if (post) {\n      const title = post.title || '게시물';\n      const description =\n        extractText(post.content).substring(0, 160) || '꼬순내 게시물';\n\n      let imageUrl = extractFirstImage(post.content);\n      if (imageUrl) {\n        if (imageUrl.startsWith('/')) {\n          imageUrl = `${baseUrl}${imageUrl}`;\n        } else if (!imageUrl.startsWith('http')) {\n          imageUrl = `${baseUrl}/${imageUrl}`;\n        }\n      } else {\n        imageUrl = `${baseUrl}/static/images/defaultDogImg.png`;\n      }\n\n      const url = `${baseUrl}/read/${postId}`;\n\n      return {\n        title: `${title} | 꼬순내`,\n        description,\n        metadataBase: new URL(baseUrl),\n        openGraph: {\n          title,\n          description,\n          url,\n          siteName: '꼬순내',\n          images: [\n            {\n              url: imageUrl,\n              width: 1200,\n              height: 630,\n              alt: title,\n            },\n          ],\n          locale: 'ko_KR',\n          type: 'article',\n        },\n        twitter: {\n          card: 'summary_large_image',\n          title,\n          description,\n          images: [imageUrl],\n        },\n      };\n    }\n  } catch (error) {\n    console.error('메타데이터 생성 중 오류:', error);\n  }\n\n  const defaultImageUrl = `${baseUrl}/static/images/defaultDogImg.png`;\n\n  return {\n    title: '게시물 | 꼬순내',\n    description: '꼬순내 게시물',\n    metadataBase: new URL(baseUrl),\n    openGraph: {\n      title: '게시물 | 꼬순내',\n      description: '꼬순내 게시물',\n      url: `${baseUrl}/read/${postId}`,\n      siteName: '꼬순내',\n      images: [\n        {\n          url: defaultImageUrl,\n          width: 1200,\n          height: 630,\n          alt: '꼬순내',\n        },\n      ],\n      locale: 'ko_KR',\n      type: 'article',\n    },\n    twitter: {\n      card: 'summary_large_image',\n      title: '게시물 | 꼬순내',\n      description: '꼬순내 게시물',\n      images: [defaultImageUrl],\n    },\n  };\n}\n\nexport default async function ReadPostPage({\n  params,\n}: {\n  params: Promise\u003C{ id: string }>;\n}) {\n  const { id: postId } = await params;\n  const post = await getPostById(postId);\n\n  return \u003CReadPostContent postId={postId} initialPost={post} />;\n}\n```","src/content/docs/fe/dunamic-meta.mdx","0df24e7fadfcb807","fe/react-batching",{"id":144,"data":146,"body":151,"filePath":152,"digest":153,"deferredRender":15},{"title":147,"editUrl":15,"head":148,"template":17,"sidebar":149,"pagefind":15,"draft":19},"UpdateBatching",[],{"hidden":19,"attrs":150},{},"### 📚 Intro\n\nsetState를 호출하면 React는 즉시 리렌더링을 수행하지 않고 해당 업데이트를 큐에 등록한 후 이벤트 핸들러의 실행이 끝날 때까지 기다린다.\n\n이 부분과 batchingUpdate이랑 연관이 있다고 하는데\nbatchingUpdate이 무엇인지 그리고 React 18에 새롭게 추가된 것이 무엇인지\n무지상태에서 파해쳐보기로 한다.\n\n---\n\n### Batching\n\nstate는 각 랜더링마다 고정되어있는데 만약 state가 여러개 바뀌면 어떻게 될까?\nsetNumber()와 setName()이런 함수가 여러번 나뉘어서 실행되나?\n\n아니다.\n불필요한 랜더링을 방지하기 위해 이벤트 핸들러의 모든 코드가 실행될 때까지 기다린다.\n즉, state의 업데이트 작업을 모아 일괄 처리하는 방식을 Batching이라고 한다.\n\n```jsx\nimport { useState } from \"react\";\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  function increaseCount() {\n    // 아래 작업들은 일괄작업으로 처리된다.\n    setCount((prev) => prev + 1);\n    setCount((prev) => prev + 1);\n    setCount((prev) => prev + 1);\n  }\n\n  return (\n    \u003Cdiv>\n      \u003Cbutton onClick={increaseCount}>+1\u003C/button>\n      \u003Cp>Count : {count}\u003C/p>\n    \u003C/div>\n  );\n}\n\nexport default Counter;\n```\n\nReact는 여러 번 호출된 setState를 내부적으로 큐에 모아두고 하나의 일괄 작업(batch)으로 처리해 단 한 번만 리렌더링을 발생시킨다.\n\n---\n\n### React 18에 추가된 Automatic Batching\n\n기존에 batching은 언제 상태를 묶어서 처리하는지 일관되지 않았다는 문제점이 있었다.\n\n```jsx\nfunction App() {\n  const [count, setCount] = useState(0);\n  const [flag, setFlag] = useState(false);\n\n  function handleClick() {\n    fetchSomething().then(() => {\n      // React 17 이하에서는 batching이 발생하지 않음\n      setCount((c) => c + 1); // 리렌더링 발생\n      setFlag((f) => !f); // 또 다시 리렌더링 발생\n    });\n  }\n\n  return (\n    \u003Cdiv>\n      \u003Cbutton onClick={handleClick}>Next\u003C/button>\n      \u003Ch1 style={{ color: flag ? \"blue\" : \"black\" }}>{count}\u003C/h1>\n    \u003C/div>\n  );\n}\n```\n\n위에처럼 onClick 같은 React 이벤트 헨들러 내부에서만 batch가 발생했다.\nfetch, serTimeout, Promise 콜백 내부에서는 batching이 일어나지 않는다.\n\n때문에 위의 코드에서 두번의 렌더링이 발생한다.\n\n하지만 React 18 이루부터는 fetch나 serTimeout안에서는 상태 업데이트도 자동 batching된다.\n\nReact 18에서는 createRoot를 사용하면 자동 배칭이 기본 적용된다.\nReactDOM.render()방식은 여전히 2번의 리렌더링이 일어난다.\n\n#### legacy render\n\n```jsx\nimport * as ReactDOM from \"react-dom\"; // 옛 방식\n// ...\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\u003CApp />, rootElement);\n```\n\n#### create Root\n\n```jsx\nimport * as ReactDOMClient from \"react-dom/client\"; // React 18 방식\n// ...\nconst rootElement = document.getElementById(\"root\");\nconst root = ReactDOMClient.createRoot(rootElement);\nroot.render(\u003CApp />);\n```\n\n---\n\n### 참고 자료\n\n- [Automatic batching for fewer renders in React 18](https://github.com/reactwg/react-18/discussions/21)","src/content/docs/fe/react-batching.mdx","54ed0f8e362f831b","network/http-https",{"id":154,"data":156,"body":161,"filePath":162,"digest":163,"deferredRender":15},{"title":157,"editUrl":15,"head":158,"template":17,"sidebar":159,"pagefind":15,"draft":19},"HTTP & HTTPS",[],{"hidden":19,"attrs":160},{},"## HTTP란?\n\nHTML 같은 문서를 가져올 수 있게 하는 Protocol이다.\n\nNetwork 카테고리에서 매우 많이 본 Protocol 자세한 내용은 블로그를 참고해 주길 바란다.\n\n[프로토콜](https://yeaseul7.github.io/neekoblog/protocol/)\n\nHTTP는 클라이언트와 서버가 서로 통신하기 위해 사용하는 프로토콜이다.\n중간에 다른 역할을 하는 개체들도 존재한다\n\n- 게이트웨이(Gateway) : 특정 서버로 가는 트래픽을 관리하는 서버\n- 프록시(Proxy) : 서버의 데이터를 캐싱해서 클라이언트와 서버간의 트래픽을 최적화하는 서버\n\n이 두가지에 대해서는 아래에서 다시 설명하겠다.\n먼저 Client와 Server의 특징에 대해 알아보자.\n\n### 이때 Client와 Server의 특징은 무엇인가?\n\n- Client : 요청을 보내는 주체\n- Server : 요청을 받아서 응답하는 주체\n\n**Client는 서버에 요청을 보내고, 서버는 요청을 받아서 응답을 보낸다.**\n주로 클라이언트는 브라우저의 역할을 수행함으로 랜더링을 위해 스크립트와 HTML문서를 요청한다.\n\n**Server는 클라이언트의 요청을 받아서 응답을 보낸다.**\nServer는 script를 응답하거나 데이터를 전달하는 역할을 수행한다.\n\nHTTP/1.1 이후 Header의 기능으로 한개의 IP 주소로 여러개의 포트를 사용할 수 있게 되었다.\n이는 **가상 호스트(Virtual Host)** 라고 부른다.\n주로 일처리가 많은 서버는 여러개의 포트를 사용해서 일처리를 하게 된다.\n예를 들어서 DB 서버와 웹 서버가 있을 때 웹 서버는 80번 포트를 사용하고 DB 서버는 3306번 포트를 사용한다.\n\n### 가상 호스트에 대해 더 자세히 짚어보자\n\n같은 IP에서 다른 도메인을 사용해서 분산처리하는 것을 의미한다.\n예를 들어서 www.naver.com 과 www.daum.net 이 있을 때 같은 IP 주소를 사용하지만 다른 도메인을 사용해서 분산처리하는 것을 의미한다.\n\n즉, 서버는 가상 호스트를 통해 여러 도매인으로 클라이언트와 통신할 수 있으며 그때 사용하는 프로토콜은 HTTP이다.\n\n프로토콜 포스트에서 설명했지만 HTTP는 Stateless 프로토콜이다.\n\n## Stateful하지 않은 HTTP는 보안을 어떻게 할까?\n\nHTTP는 기본적으로 보안 설정이 되어있지 않다.\n하지만 TCP와 TLS를 통해 암호화 하여 HTTPS로 보안을 강화할 수 있다.\n\n### TLS는 무엇인가?\n\nTLS(Transport Layer Security)는 데이터를 암호화하여 보호하는 프로토콜이다.\n이것을 이용해 암호화된 HTTP 프로토콜을 HTTPS 프로토콜이라고 부른다.\n(암호화 관련하여 TLS 이외에 SSL이라는 프로토콜도 존재한다.\nSSL은 TLS의 이전 버전이다.)\n\nHTTP와 HTTPS의 차이는 즉, 보안화된 프로토콜의 차이가 있다고 볼 수 있다.\n\n---\n\n## HTTP\n\n1. HTTP는 Header에 의해 확장성이 높다.\n   HTTP는 header의 다양한 옵션을 통해 추가 기능을 구현할 수 있다.\n\n2. Stateless 프로토콜이지만, Cookie를 통해 상태를 유지할 수 있다.\n   계속 말했듯이 HTTP는 Stateless 프로토콜이다. 그래서 Cookie를 통해 상태를 유지하곤 하는데, 이 Cookie는 클라이언트에서 데이터를 저장하여 Session을 유지하는 역할을 수행한다.\n\n   - 로그인으로 예시를 들어보자\n   - 클라이언트에서 유저가 아이디와 비밀번호를 작성해서 서버에 POST 요청을 보낸다.\n   - 서버는 인증 절차를 거친 후 Session ID를 생성하고 HTTP header의 Set-Cookie 옵션을 통해 클라이언트에 전달한다.\n   - 클라이언트는 받은 Session ID를 쿠키에 저장한다.\n   - 이후 요청시 쿠키에 저장된 Session ID를 함께 전송하여 인증 상태를 유지한다.\n\n3. 데이터 손실을 방지하기 위해 TCP를 신뢰한다.\n   TCP는 데이터를 전송하기 전에 3-way handshake를 통해 연결을 설정하고 데이터를 전송한다.\n   이는 프로토콜 포스팅에서 설명했다.\n   [프로토콜](https://yeaseul7.github.io/neekoblog/protocol/)\n\n   여러 왕복이 필요한 TCP 연결을 설정하기 위해 HTTP/1.0은 기본적으로 요청을 보낼때마다 TCP 연결을 여는 동작을 수행한다.\n   이는 여러 요청을 보내는 경우 네트워크 부하가 커지는 문제가 있다.\n   이점을 해결하기 위해 HTTP/1.1은 파이프 라이닝 개념을 도입하고 HTTP/2는 멀티플렉싱 개념을 도입하여 네트워크 부하를 줄였다.\n\n---\n\n## HTTP/1.1의 파이프 라이닝 개념\n\n개념은 **'작업이 처리가 된 이후에도 TCP 연결을 유지할 수 있게 하는 것'** 이다.\n이걸 **Keep-Alive Connection** 이라고 부른다.\n\n이는 응답을 기다리지 않고 단일 연결을 통해 HTTP 요청을 보내고 있는 것을 확인할 수 있다.\n이로인해 요청 처리 속도는 빨라질 수 있지만 순서를 맞춰서 응답하는 부분이 다루기 어렵다.\n여러가지 오청을 계속 보낼 수 있어서 속도가 빨라진다는 장점이 있지만 HTTP Header는 요청마다 같은 정보를 담기 때문에 비효울적일 수 있다.\n같은 정보를 계속 보내면 보내는 데이터 양이 증가한다는 의미이고 이는 회선 비용을 증가시킨다.\n헤더는 패킷에 포함되는데 헤더에 데이터가 쌓인다는 것은 패킷의 양도 증가시킨다는 의미이다.\n패킷의 양이 많아지면 PPS가 늘어난다.\n(PPS란 초당 처리해야 될 패킷 수를 의미한다.)\n이로인해 HTTP/2의 멀티 플랙싱 개념이 도입되었다.\n\n---\n\n## HTTP/2의 멀티 플렉싱 개념\n\n하나의 연결에서 여러 요청과 응답의 순서를 따로 신경쓰지 않는 방법이다.\nHTTP/2의 멀티 플렉싱은 PPS가 늘어나는 한계를 해결하기 위해서 도입되었는데 이는 헤더 압축을 이용한 것이다.\n\n헤더는 허프만 코드를 이용하여 압축하는데\n이 알고리즘은 회전 양이 많아질수록 유리하다.\n관련 포스팅은 별도로 남겨두겠다.","src/content/docs/network/http-https.mdx","54b0cbcb60af58d5","fe/state",{"id":164,"data":166,"body":171,"filePath":172,"digest":173,"deferredRender":15},{"title":167,"editUrl":15,"head":168,"template":17,"sidebar":169,"pagefind":15,"draft":19},"useState",[],{"hidden":19,"attrs":170},{},"### 📚 Intro\n\nbatchingUpdate에 대해 공부하기 전에 State의 동작원리에 대해 더 자세히 알아봐야 겠다고 생각했다.\n공식문서를 보니 state동작에 대한 얘기가 많아서 이것부터 파해쳐보자\n\n---\n\n### ❤️ State 업데이트 큐\n\n`setState`를 여러번 하면 한번만 실행된다.\n\n```jsx\nconst [count, setCount] = useState(0);\n\n// 이런 방식으로 연속적인 setState를 호출하면\nsetCount(count + 1); // 0 -> 1\nsetCount(count + 1); // 0 -> 1 (여전히 count는 0)\nsetCount(count + 1); // 0 -> 1 (여전히 count는 0)\n```\n\nsetState는 변수를 설정하면 렌더링 큐에 들어가는 것이지 바로 바뀌지 않는다.\n그래서 다음 렌더링을 큐에 넣기 전에 작업을 더 해야되는 경우가 생긴다.\n\n```jsx\n//이전 값 사용한 예시\nsetCount((prev) => {\n  const next = prev + 1;\n  // 여기서 여러 작업 가능\n  console.log(\"다음 값은:\", next);\n  return next;\n});\n```\n\n그럴때 위처럼 작업하면 되는데 이를 updater function이라고 부른다.\n\n```jsx\n//이전 값 여러번 사용한 예시\nsetNumber((n) => n + 1);\nsetNumber((n) => n + 1);\nsetNumber((n) => n + 1);\n```\n\n이런 코드가 있으면 처음 n이 0이라고 할 때 함수 각각 하나씩 큐에 추가가 된다.\n그리고 렌더링중에 이 함수들이 실행되는 흐름은\nn=0 -> n=1 -> n=2 -> n=3 이렇게 된다.\n\n각 렌더링의 state 값은 고정되어있다.\n\n```jsx\n//state 교체 개념\n\u003Cbutton onClick={() => {\n  setNumber(number + 5);\n  setNumber(n => n + 1);\n}}>\n```\n\n위와 같이 하면 처음 number는 사용되지 않는다. 교체되는 개념이다.\n조금 더 확실히 하면\n\n```jsx\n\u003Cbutton onClick={() => {\n  setNumber(number + 5);\n  setNumber(n => n + 1);\n  setNumber(42);\n}}>\n```\n\n이렇게 했을 때 결과가 42가 된다.","src/content/docs/fe/state.mdx","19b4cf99b328bde6","fe/web-standards",{"id":174,"data":176,"body":181,"filePath":182,"digest":183,"deferredRender":15},{"title":177,"editUrl":15,"head":178,"template":17,"sidebar":179,"pagefind":15,"draft":19},"웹표준",[],{"hidden":19,"attrs":180},{},"### 웹 표준이란?\n\n여러 국제 표준 기구가 정한 규칙\n\n웹 표준은 웹의 사용성과 접근성을 극대화 하도록 조정된다.\n\n**종류**\n\n- IETF(Internet Engineering Task Force) : URI, HTTP 등 설정과 사용에 대한 표준 **(STD)**\n- W3C : 마크업 언어에 대한 명세 (HTML, XHTML, SVG, CSS 등)\n- Ecma : 스크립팅 표준\n\n웹 표준이 없던 1990년대 말 쯤에는 표준이 없어서 브라우저마다 사이트를 만들어야 했다. (Explore, 넷스케이프)\n\n웹표준을 지켜서 개발하면 크롤러가 나의 사이트의 구조와 콘텐츠를 더 명확하게 이해할 수 있다. **(SEO 최적화)**\n\n[웹표준](https://www.w3.org/standards/)은 여기서 확인할 수 있다.\n\n### 웹 접근성이 무엇인가요?\n\n웹 표준은 웹 접근성, 사생활 보호, 보안, 국제화의 측면에서 고려되어야 한다고 한다.\n그 중 웹 접근성은 장애를 가진 사람과 가지지 않은 사람 모두가 웹사이트를 이용할 수 있게 한다는 것을 의미 한다.\n\n예를들어 시각장애인은 '스크린 리더'라는 것을 이용해서 웹페이지 내용을 파악하는데\n스크린 리더가 읽을 수 있게 이미지만 올려놓는게 아닌 alt 등으로 설명을 추가해야한다.\n이게 웹 접근성을 고려한 것이다.\n\n```\n\u003Cimg arc = \"img/login.png\" alt=\"로그인 />\n```\n\n---\n\n_출처: https://goddaehee.tistory.com/244 [갓대희의 작은공간:티스토리]_","src/content/docs/fe/web-standards.mdx","c4d9d39505d54630","fe/web-server",{"id":184,"data":186,"body":191,"filePath":192,"digest":193,"deferredRender":15},{"title":187,"editUrl":15,"head":188,"template":17,"sidebar":189,"pagefind":15,"draft":19},"웹서버",[],{"hidden":19,"attrs":190},{},"### 1. 웹서버란?\n\n웹서버는 하드웨어, 소프트웨어 관점 두가지로 해석될 수 있다.\n나는 정의를 내리려고 했는데 관점에따라 두가지 정의가 있을 수 있다고 한다.\n\n하드웨어 관점 : HTTP 요청을 받고 HTML 같은 문서를 반환하는 **컴퓨터**\n소프트웨어 관점 : 클라이언트로부터 HTTP 요청을 받아서 HTML문서 같은 페이지를 반환하는 **소프트웨어**\n\n```jsx\n// 예시\nApache, Nginx, Node.js의 http.createServer() 같은 것\n```\n\n### 2. 웹서버 특징\n\n- 웹서버는 HTML 문서를 저장하고 있어야 한다.\n- 항상 실행중이어야 한다.\n- 항상 인터넷과 연결되어있다.\n- 항상 같은 IP를 가지고 있다.\n- 제 3자에 의해 유지보수 된다.\n\n> 예를 들어 우리가 깃허브에 HTML 문서를 올리고 그걸 Vercel과 연동해서 Vercel이 깃허브 레포에 있는 HTML문서를 가지고 있고 개발자가 서버를 키면 그게 고정된 IP로 호스팅 되는 경로이다.\n\n**정적 사이트**\n→ 있는 그대로 제공되는 것\n파일 내용이나 데이터가 정적입니다.\n말그대로 모든 사용자가 동일한 내용을 본다.\n\n**동적 사이트**\n→ 동적으로 콘텐츠가 바뀔 수 있는 것\n사용자마다 다른 데이터를 볼 수 있는 사이트\n\n---\n\n### 1. WAS란?\n\n동적인 content를 처리하고 제공하는 서버이다.\n웹 애플리케이션 실행 및 데이터 처리, 웹 서버와 클라이언트 간의 중계 역할을 한다.\n\n```jsx\n// 예시\nTomcat, JBoss, WebLogic, WebSphere;\n```\n\n조금 더 자세히 설명하자면 WAS는 클라이언트의 요청에 따라 DB에서 정보를 가져오거나, Web application을 실행해서 동적인 웹 페이지를 생성한 후 결과를 웹 서버에 전달한다.\n\n#### 보통은 WAS서버와 웹서버가 협업하여 사이트가 실행된다.\n\n쇼핑몰 같은 경우 검색, 장바구니 같은 것은 WAS 서버가 처리하고 css나 정적 image 들은 웹서버에서 제공한다.","src/content/docs/fe/web-server.mdx","73e8b150cfac8966","fe/webpack",{"id":194,"data":196,"body":201,"filePath":202,"digest":203,"deferredRender":15},{"title":197,"editUrl":15,"head":198,"template":17,"sidebar":199,"pagefind":15,"draft":19},"webpack",[],{"hidden":19,"attrs":200},{},"webpack은 Javascript 애플리케이션을 위한 Static Module Bundler이다.\n\n애플리케이션을 처리할 때 필요한 모듈을 매핑하고 하나 이상의 번들을 생성하는 'Dependency Graph'를 만든다.\n\n### Dependency Graph\n\n어떤 파일이 다른 파일에 의존할때마다 webpack은 이걸 의존성으로 취급한다.\n\n#### 그러면 어떻게 의존되어있는 것을 알까?\n\n먼저 webpack은 애플리케이션을 처리할 때, command line 또는 설정파일(webpack.config.js)에 정의된 모듈 목록에서부터 처리를 시작한다.\n이걸 Entry Point라고 한다.\n\nEntry Point에서 webpack은 필요한 모든 모듈을 포함하는 Dependency Graph룰 재귀적으로 빌드한 다음, 모든 모듈을 브라우저에 의해 로드 되는 작은 수의 번들로 묶는다.\n\n이렇게 되면 HTTP/1.1의 경우 요청 간의 대기시간의 최적화 할 수 있으므로 빠르게 로드 할 수 있다.","src/content/docs/fe/webpack.mdx","3e59ec1e56e47ace","network/network",{"id":204,"data":206,"body":211,"filePath":212,"digest":213,"deferredRender":15},{"title":207,"editUrl":15,"head":208,"template":17,"sidebar":209,"pagefind":15,"draft":19},"Network?",[],{"hidden":19,"attrs":210},{},"import { Image } from \"astro:assets\";\nimport networkImg from \"../../../assets/images/network/network.jpeg\";\nimport networkKindImg from \"../../../assets/images/network/networkKind.jpeg\";\nimport nodeImg from \"../../../assets/images/network/node.png\";\nimport packetImg from \"../../../assets/images/network/packet.png\";\n\n### 네트워크가 뭐에요?\n\n\u003CImage\n  src={networkImg}\n  alt=\"네트워크 개념도\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"jpeg\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n네트워크는 두대 이상의 컴퓨터에서 데이터나 정보를 공유하기 위해 존재한다.\n\n(두대 이상의 노드에서 데이터나 정보를 공유하기 위해 존재한다.)\n\n네트워크의 종류는 크게 두가지로 볼 수 있다.\nWAN과 LAN이 존재하는데 *Wide Area NerWork*와 *Local Area Network*의 축약어로 해석 그대로\n**광역 통신망** 과 **근거리 통신망**이라고 불린다.\nLAN은 근거리 통신망으로 사내에서 사용하는 네트워크를 예로 들 수 있다.\nWAN은 우리가 보통 사용하는 해외사람들이랑 소통하기 위해 존재하는 네트워크라고 생각할 수 있다.\n\n\u003CImage\n  src={networkKindImg}\n  alt=\"네트워크 종류\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"jpeg\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n그밖에 종류는 LAN, WLAN, WAN, MAN, PAN, SAN, CAN, VPN 등 이 존재한다.\n\n---\n\n#### 네트워크 이해를 돕는 기본 용어\n\n\u003CImage\n  src={nodeImg}\n  alt=\"네트워크 노드\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n##### 노드\n\n노드는 데이터를 수신, 전송, 저장할 수 있는 네트워크 내의 연결지점이다.\n네트워크가 노드에 접근하려면 어디에 접근하는지 알 수 있는 IP주소같은 식별 정보가 필요하다.\n노드는 따라서 IP주소같은 식별 정보를 가지고 있는 컴퓨터, 프린터, 모뎀, 브리지, 스위치 등 이라고 볼 수 있다.\n\n##### IP주소\n\n네트워크에 연결된 각 컴퓨터나 기기는 데이터를 주고 받기 위해 고유 번호를 부여받는다.\n이 고유번호는 IP주소라고 하며, 네트워크에서 데이터를 전송할 때 주소와 같은 역할을 한다.\n이 정보를 패킷의 해더에 포함시켜 전송하면 어느 컴퓨터(노드)로 가야하는지 알 수 있다.\n\n##### IP(Internet Protocol)\n\n인터넷이 연결된 네트워크에서 정보를 주고 받을 때에는 정해진 규칙이 있다.\n이 규칙을 IP즉, 인터넷 프로토콜이라고 한다.\n따라서 IP 주소는 '인터넷이 통하는 네트워크 규칙에서 정한 주소'이다.\nIP에도 체계가 있으니 한번 참고해보는 것도 좋을 것 같다.\n\n\u003CImage\n  src={packetImg}\n  alt=\"패킷 구조\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n##### 패킷(Packet)\n\n패킷은 pack과 bucket의 합성어로 네트워크에서 정보를 주고 받을 때 사용하는 작은 데이터 조각을 의미한다.\n예를 들어 IP 주소가 포함된 작은 데이터 단위는 패킷이다.\n\n##### 라우터\n\n네트워크를 연결해주는 장치다. 라우터는 데이터를 패킷으로 나눠서 어디로 가야할지 정해주고 전송한다.\n예를 들어 항공에서 관제탑 같은 역할을 한다고 볼 수 있다. 비행기는 패킷이다.\n\n##### 라우팅\n\n라우터가 데이터를 어디로 가야할지 정해준다고 했는데 정하는 과정을 라우팅이라고 볼 수 있다.\n라우터의 라우팅 방식에 의해 데이터가 어떻게 전송될지 정해지는 것이다.\n\n##### 스위치\n\n스위치는 동일한 네트워크, 즉 단일 네트워크 내에서 장치(노드) 간의 연결을 관리하고 데이터 패킷이 올바른 목적지로 도달하도록 한다.\n라우터와 비슷한 기능을 한다고 볼 수 있다.\n라우터와 차이점은 라우터는 서로 다른 네트워크 간에 데이터를 전송하는 장치이고\n스위치는 동일한 네트워크 내에서 데이터를 전송한다.\n\n이 두 장치는 함께 작동될 수도 있는데, 사무실 내 프린터같은 장치들을 연결하고 그 장치 들은 스위치를 통해 라우터와 연결되며 라우터는 이 네트워크를 외부 네트워크와 연결한다.\n\n##### 포트\n\n네트워크에서 특정 서버나 애플리케이션을 식별하고 통신하는 데 사용되는 논리적인 접접이다.\n'포트번호' 라는 말이 자주 나오는데 이것은 접점의 장소 번호이다.\n\n이 번호가 필요한 이유를 알아보자.\n서버를 실행할 때, 종종 8080이나 3000같은 번호를 볼 수 있다.\n서버가 인터넷에서 통신하기 위해서는 어디로 연결할지 알아야 하는데 이 때 포트번호가 필요하다.\n\n---\n\n##### 자료 출처\n\n_출처: https://velog.io/@rockwellvinca/Network-%ED%8C%A8%ED%82%B7%EC%9D%98-%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%83%9D%EC%84%B1%EA%B3%BC%EC%A0%95_\n_출처: https://steemit.com/network/@sapphire317/link-node-cloud_","src/content/docs/network/network.mdx","ecb21119c36364bf","retrospect/gdsc",{"id":214,"data":216,"body":221,"filePath":222,"digest":223,"deferredRender":15},{"title":217,"editUrl":15,"head":218,"template":17,"sidebar":219,"pagefind":15,"draft":19},"GDSC Retrospect",[],{"hidden":19,"attrs":220},{},"### GDSC란 무엇인가요?\n\n학생들이 개발/리더십 능력을 키울 수 있도록 지원하는 프로그램입니다.\n[GDSC성공회대 공식 사이트](https://gdsc.community.dev/sungkonghoe-university/)에서 더 자세한 내용을 참고할 수 있습니다.\n\n### GDSC에서 무엇을 했나요?\n\n- **Web Study**\n  매주 React, Next.js, Typescript등 프로젝트에 필요한 기술들을 학습하였습니다.\n  여기서 처음으로 React를 사용해보았으며 실무를 통해서 프로젝트를 마칠 수 있는 정도로 빠르게 성장할 수 있었습니다.\n  이 과정에서 React, Vue, Angular등 다양한 프레임워크가 존재한다는 것을 깨달았으며\n  Next.js를 사용해봄으로써 SSR에 대해 더 잘 이해할 수 있었습니다.\n- **정규 세션**\n  Web, Backend, Mobile 파트가 모여서 프로젝트를 구상하고 참여함으로써 각 파트와 소통할 수 있었습니다.\n  소통 과정에서 Backend와 api로 소통하는 방법 혹은 프로토콜의 이해를 도울 수 있었습니다.\n- **해커톤**\n  전세계 GDSC 소속 학생들을 대상으로 열린 대규모 챌린지 입니다.\n  Mintalk라는 프로젝트에 참여하였으며 해당 프로젝트는 의사들과 환자들을 연결해주는 서비스입니다.\n  정신과를 주 타겟으로 삼았으며 mock data를 기반으로 프로젝트를 출시하였습니다.\n\n### 성장 Point\n\n- 팀원들과 소통하면서 개발에 대해 지식이 부족하였기에 이해를 못하는 등의 어려움이 있었습니다.\n  이를 해결하기 위해서 팀원들과 소규모 스터디를 운영하고 지식을 공유하는 시간을 가졌고 일주일에 1개의 post를 올리는 챌린지에 참여하게 되었습니다.\n  또한 다른 사람들에게 스스로의 주장을 더 어필하기 위해서 탄탄한 배경이 있어야함을 느꼈습니다.\n  개발에 있어서 웹에 대한 기본 지식이 매우 부족하다고 생각했습니다. 스터디와 더불어서 개인 학습시간을 늘려 GDSC에 처음 참여할떄와 비교해 많은 지식을 얻어갔음을 느꼈습니다.\n  어느 솔루션을 해결할 때 공식문서를 최대한 이해해야함을 느꼈습니다.\n  처음에는 무작정 구글링을 통해 기능 구현에만 집중했습니다. 코드 복붙보다 동작원리를 최대한 이해한 후 기능을 구현하는 것이 스스로의 성장 속도를 증진시킴을 이해했습니다.\n- 사람들과 협업하면서 **같이 고민**하는 방법을 배웠습니다.\n  혼자 문제를 해결하려 노력하기보다 팀원들과 소통을 통해 어려움을 해결하고 잊지 않으려 노력하는 것이 효율이 더 좋을 수 있다는 것을 꺠달았습니다.\n\n_작성 일자 : 2024.06.25_","src/content/docs/retrospect/gdsc.mdx","37331edd137bba25","network/protocol",{"id":224,"data":226,"body":231,"filePath":232,"digest":233,"deferredRender":15},{"title":227,"editUrl":15,"head":228,"template":17,"sidebar":229,"pagefind":15,"draft":19},"Protocol",[],{"hidden":19,"attrs":230},{},"import { Image } from \"astro:assets\";\nimport protocolComputeImg from \"../../../assets/images/protocol/protocolCompute.png\";\nimport clientImg from \"../../../assets/images/protocol/client.png\";\nimport os7Img from \"../../../assets/images/protocol/os7.png\";\nimport applicationLayerImg from \"../../../assets/images/protocol/applicationLayer.png\";\nimport presentationLayerImg from \"../../../assets/images/protocol/presentationLayer.png\";\nimport sessionLayerImg from \"../../../assets/images/protocol/sessionLayer.png\";\nimport transportImg from \"../../../assets/images/protocol/transport.png\";\nimport networkImg from \"../../../assets/images/protocol/network.png\";\nimport dataLinkImg from \"../../../assets/images/protocol/dataLink.png\";\nimport pysImg from \"../../../assets/images/protocol/pys.png\";\nimport os7LayerImg from \"../../../assets/images/protocol/os7Layer.png\";\nimport tcpImg from \"../../../assets/images/protocol/tcp.png\";\nimport hand3Img from \"../../../assets/images/protocol/3hand.png\";\nimport hand4Img from \"../../../assets/images/protocol/4hand.png\";\n\n들어가면서.\n\n웹 개발자로 함은 다양한 네트워크 통신으로 인해 화면이 어떻게 그려지는지  \n그리고 어떤 방식으로 내가 원하는 데이터가 오고 가는지 이해할 필요가 있다고 생각한다.\n\n그중에서 기초적인 프로토콜과 OSI 7 Layer와 TCP/IP에 대해 먼저 살펴보고자 한다.\n\n먼저 프로토콜이 무엇인지 알아보자.\n\n### 프로토콜\n\n컴퓨터 내부 혹은 컴퓨터 사이에서 데이터 교환 방식을 정의하는 규칙이다.\n\n강아지가 기분이 좋으면 꼬리를 흔들고 경계하면 꼬리를 굳힌다.  \n이는 강아지들 사이에서 통하는 규칙이라고 볼 수 있다.  \n이처럼 컴퓨터 사이에서도 데이터를 주고 받을 때 규칙이 필요하다.  \n안그러면 어떤 컴퓨터는 이해하고 다른 컴퓨터는 이해하지 못하는 상황이 생길 수 있다.\n\n이러한 규칙이 바로 프로토콜이다.\n\n\u003CImage\n  src={protocolComputeImg}\n  alt=\"프로토콜 개념도\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n이 프로토콜에도 종류가 있다.  \n상태 프로토콜, 무상태 프로토콜  \n즉, 기억을 하냐 못하냐의 차이라고 볼 수 있다.\n\n#### 상태 프로토콜(Stateful protocol)\n\nServer side에서 server와 client가 동작한 상태 정보를 저장하는 형태이다.  \n이것을 Server의 session에 저장하곤 하는데 이 session 정보에 따라 서버의 응답이 달라진다.  \nex)TCP handshake\n\n#### 무상태 프로토콜(Stateless prorocol)\n\nServer의 응답이 client session 상태와 독립적이며 상태를 저장하지 않는다.  \n따라서 항상 요청할 때 필요한 정보를 모두 담아서 보내야 하는 상황이 생긴다.  \nex) UDP/ HTTP\n\n\u003CImage\n  src={clientImg}\n  alt=\"상태 프로토콜과 무상태 프로토콜 비교\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n무상태 프로토콜, 상태 프로토콜은 각각 장단점이 존재한다.  \n무상태는 서버 사이드에 세션 정보를 저장하지 않는 대신 서버의 자원을 비교적 효율적으로 사용할 수 있다.  \n하지만 모든 필요 자원을 담아서 보내야 한다는 전제 하에 보안에 취약하다.  \n상태는 반대라고 볼 수 있다.\n\n---\n\n프로토콜이 컴퓨터가 데이터를 주고 받을 때 쓰이는 규칙이라고 했는데, 그 규칙은 어떤 과정에서 필요한걸까?  \n바로 데이터를 전송하는 네트워크에서 필요하다.  \n이 과정에서 많은 프로토콜이 쓰이는데 이것을 계층적으로 구분지은게 모델이다.\n\n계층적으로 구분지은 이유는 데이터를 한번에 주고 받으면 에러 관리도 힘들고 통신 제어도 힘들다.  \n이를 계층을 나누고 역할을 분배하여 처리할 수 있게 한다. 이를 분할 정복(Divide and Conquer)이라고 한다.\n\n대표적으로 OSI 7 Layer 모델과 TCP/IP 모델이 존재한다.\n\n#### OSI7 Layer Model\n\n\u003CImage\n  src={os7Img}\n  alt=\"OSI 7 Layer 모델\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n이 모델은 산업 표준 모델이다.  \n초창기 네트워크의 표준을 만들기 위해 해당 모델이 나타났다.\n\n**OSI 7 Layer - Application Layer[응용 계층]**\n\n\u003CImage\n  src={applicationLayerImg}\n  alt=\"Application Layer 응용 계층\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n소프트웨어가 사용자에게 데이터를 제공하기 위해 의존하는 프로토콜이다.  \n이 Layer는 이메일이나 브라우저 같은 소프트웨어 애플리케이션이 통신을 열기 위해 존재한다.\n\n대표적으로 **HTTP, FTP, Telnet, DHCP** 프로토콜이 존재한다.\n\n**OSI 7 Layer - Presentation Layer[표현 계층]**\n\n\u003CImage\n  src={presentationLayerImg}\n  alt=\"Presentation Layer 표현 계층\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n데이터를 사용할 수 있게 해주는 계층이다.  \n데이터를 사용할 수 있게 암호화, 변환, 압축을 담당한다.  \n이렇게 데이터를 변환하는 이유는 수신하는 노드(컴퓨터)가 다른 인코딩 방법을 사용할 수 있기 때문이다.\n\n대표적으로 **ASCII, MPEG, JPEG 프로토콜**이 존재한다.\n\n​\n\n**OSI 7 Layer - Session Layer[세션 계층]**\n\n\u003CImage\n  src={sessionLayerImg}\n  alt=\"Session Layer 세션 계층\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n세션이란? 여기서 session은 통신이 시작될 때부터 종료 시점까지를 의미한다.  \n따라서 이 계층은 통신 시작과 끝을 결정하는 역할을 하고 리소스를 낭비하지 않게 세션을 개방하고 닫는 등의 역할을 한다.  \n데이터를 전송하다가 중간에 끊기면 처음부터 다시 전송을 재개해야하는데  \n이 계층에서 체크포인트를 설정해서 그 지점부터 재전송을 할 수 있게 한다.\n\n대표적으로 **SSH, TLS, RPC 프로토콜**이 존재한다.\n\n**OSI 7 Layer - Transport Layer[전송 계층]**\n\n\u003CImage\n  src={transportImg}\n  alt=\"Transport Layer 전송 계층\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n세션 계층에서 데이터를 가져와서 세그먼트 단위로 조각내는 역할을 한다.  \n연결 속도가 빠른 쪽이 느린쪽을 압도하지 않도록 전송 속도를 조정하기도 한다.  \n또한 수신 완료 여부를 파악하고 오류 제어를 수행한다.\n\n**OSI 7 Layer - Network Layer[네트워크 계층]**\n\n\u003CImage\n  src={networkImg}\n  alt=\"Network Layer 네트워크 계층\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n전송 계층의 세그먼트를 송신자의 장치에서 패킷 단위로 쪼갠다. 그리고 수신 장치에서 다시 패킷을 조립한다.  \n이런 과정을 진행할 수 있게 데이터가 최적의 경로로 이동할 수 있게 라우팅한다.\n\n이 계층은 송신 장치와 수신 장치가 같은 네트워크에 있다면 필요 없다.\n\n대표적으로 **IP, ICMP 프로토콜**이 존재한다.\n\n장비 : 라우터\n\n**OSI 7 Layer - Data Link Layer[데이터 링크 계층]**\n\n\u003CImage\n  src={dataLinkImg}\n  alt=\"Data Link Layer 데이터 링크 계층\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n네트워크 계층에서 받은 패킷을 더 작은 프레임으로 세분화한다.  \n이 프레임들이 통신하는데에 있어서 흐름과 오류를 제어한다.  \n이 계층은 같은 네트워크에 있는 장치들 간의 데이터 전송도 담당한다.\n\n데이터 링크 계층은 머리와 꼬리에 데이터 수신 장치와 송신 장치 주소 등의 정보를 제공한다.  \n그 정보는 MAC주소라고 할 수 있다.\n\nMAC : Media Access Control Address\n\n대표적으로 **이더넷(Ethernet), PPP, UART 프로토콜**이 존재한다.\n\n장비 : 스위치, 브릿지\n\n**OSI 7 Layer - Physical Layer[물리 계층]**\n\n\u003CImage\n  src={pysImg}\n  alt=\"Physical Layer 물리 계층\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\nHub, router, cable 등 물리 매체를 통해 상위 계층에 전송된 데이터를 다른 시스템에 전기적 신호를 통해 전송하는 계층이다.  \n대표적으로 **1000BASE-T, RS-232, RS-485 프로토콜**이 존재한다.\n\n장비 : HUB, 리피터, 모뎀\n\n---\n\n#### TCP/IP 4 계층\n\nTCP는 OSI 7과 다르게 각 계층이 종속적으로 이루어져있다.  \nOSI가 있는데 TCP가 또 만들어진 이유는 IP 규칙으로만 통신하기에 불안정 했던 단점들을 커버하기 위함이다.\n\n이는 패킷 전송을 제어해서 신뢰성을 보증한다.\n\n\u003CImage\n  src={os7LayerImg}\n  alt=\"TCP/IP 4 계층 모델\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n**TCP-Network Interface Layer[네트워크 인터페이스 계층]**\n\n하드웨어적인 요소와 관련된 모든 것을 지원하는 계층이다.  \n물리적인 주소를 지정하고 오류를 감지해낸다.\n\n**TCP - 인터넷 계층**\n패킷을 목적지까지 전송하는 역할을 하며 라우팅, 주소 지정, 패킷 포워딩 등을 한다.\n\n**TCP- 전송 계층**\n애플리케이션 간에 데이터 흐름과 오류를 제어한다.\n\n이 과정에서 일어나는 TCP 3-Way Handshake와 4-Way Handshake를 알 필요가 있다.\n\n먼저 데이터를 전송하기 전에 연결하는 과정에서 3 Way Handshake가 일어난다.\n\n\u003CImage\n  src={tcpImg}\n  alt=\"TCP 3-Way Handshake\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n여기서 SYN는 synchronize sequence numbers ACK는 acknowledgements의 약자이다.\n\n그림대로 3번의 확인 절차를 통해 연결할 준비를 한다.\n클라이언트와 서버가 \"너 데이터 받을 준비 됐어?\" -> \"나 준비 완료\" -> \"나도 준비 완료\" 이런 과정을 거친다고 생각하면 된다.\n\n**CLOSED는 닫힌 상태\nLISTEN은 요청 대기 상태\nSYN-SENT는 SYN 요청 상태\nSYN-RECEIVED는 SYN 요청을 받은 상태\nESTABLISHED는 연결 확인 상태 이다.**\n\n그리고 데이터 교환 과정이 일어난다.\n\n\u003CImage\n  src={hand3Img}\n  alt=\"TCP 데이터 교환 과정\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\nESTABLISHED 상태에서 데이터를 보내면 송신, 수신측은 전송이 잘 되었다는 의미로 ACK 응답을 보내는데  \n이게 안오거나 하면 송신측이 계속 데이터를 보낸다.\n\n데이터를 교환하고 연결 종료 될 때 4 Way Handshake 과정이 일어난다.\n\n\u003CImage\n  src={hand4Img}\n  alt=\"TCP 4-Way Handshake\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n이것도 송신측과 수신측이  \n\"나 이제 다 보냈어\"=> \"오케 닫을게\", \"닫았어\" => \"나도 닫을게\" 이렇게 주고 받는다고 이해하면 된다.\n\n_TCP- 응용 계층_\n응용 프로그램들이 네트워크를 이용할 수 있게 암호화, 사용자 인증을 수행하는 역할이다.\n\n---\n\n이상으로 TCP와 OSI 7 Layer등 프로토콜과 모델에대해 살펴보았다.\n\nCS 측면에서 모뎀이 무엇인지, HUB가 무엇인지 등을 더 자세히 살펴 볼 필요가 있다.\n\n그리고 TCP 통신과 브라우저 작동과도 연계가 되어있는데\n\n이 부분에 대해서 추후에 리포팅 하겠다.\n\n참고로 같은 내용을 네이버 블로그에서도 다루는 중이다.\nhttps://blog.naver.com/neeko_k/223590184796","src/content/docs/network/protocol.mdx","477418a2c3e242c1","retrospect/retro2025",{"id":234,"data":236,"body":241,"filePath":242,"digest":243,"deferredRender":15},{"title":237,"editUrl":15,"head":238,"template":17,"sidebar":239,"pagefind":15,"draft":19},"retrospect 2025",[],{"hidden":19,"attrs":240},{},":::caution\n위의 리스트 한달에 한번 확인하기\n:::\n\n#### 주최적으로 발전하는 개발자\n\n2025년에는 여행도 많이 다녀오고 학교 졸업도 해야되는 상황이라 놓친것이 한가득이었다.\n매일 매일 1시간 씩만 투자해서 공부를 했더라면 지금의 나는 더 나은 개발자가 되어있지 않을까.\n\n지금의 나는 실전은 강하지만 이론이 약한것이 많다.\n그렇기에 박식한 개발자가 되기위해 많은 노력이 필요하다.\n올해 중간에는 이직을 목표로 열심히 공부했던 때도 있었지만 유종의 미를 거두지 못했다는 아쉬움이 있다.\n\n내년에는 지금 개발하고 있는 \"꼬순내\"라는 서비스를 더 발전시켜보고 싶다.\n모바일 웹으로도 출시하고 다양한 기능을 추가하고 싶다.\n코드 리뷰도 다양한 사람에게 받으며 발전시키고 싶다.\n\n### 2026년 목표 리스트\n\n- 이직하기\n- 개발 블로그 일주일에 한개 무조건 작성하기\n- 백준 플레티넘 찍기\n- 꼬순내 모바일 출시 및 모르는 유저 만들기\n- 몸무게 46kg 찍기 및 40키로대 유지하기\n- 책 한달에 한권 읽기\n- 월 지출 100만원 이하로 만들기\n- 영양제 챙겨먹기\n- 강아지 피부병 낫게 하기\n- 연봉 4천대로 진입하기\n- 팩 1주일에 한번 무조건 하기\n- 헬스 1주일에 한번 무조건 가기","src/content/docs/retrospect/retro2025.mdx","42a9f5705d42f2e7","retrospect/skhu-contest",{"id":244,"data":246,"body":251,"filePath":252,"digest":253,"deferredRender":15},{"title":247,"editUrl":15,"head":248,"template":17,"sidebar":249,"pagefind":15,"draft":19},"경진대회 회고(SKHU)",[],{"hidden":19,"attrs":250},{},"## 2023년 소프트웨어 경진대회 대상을 수상[회고록]\n\n![이미지](https://yeaseul7.github.io/neekoBlog/images/softwareAward1.png)\n\n### 프로젝트 이름\n\n**domidomi**\n\n💼 교내 행복 기숙사에 업무 효율을 높이기 위한 B2B 프로젝트\n\n많은 근로생들이 근무하는 환경에서 업무 시스템이 매우 비효율 적이었고 NAS를 이용한 운영은 파일 업로드와 운영관리를 복잡하게 하였다.  \n따라서 근로생부터 교직원분들까지 모두가 쉽게 이용 가능한 프로젝트를 개발하였다.\n\n### 프로젝트 기술\n\n`Next.js`, `React.js`, `Typescript`, `Styled-compoenent`, `Emotion`, `Vercel`,`Postman`, `Spring`, `Notion`, `Mysql`\n\n---\n\n### 기획 및 설계\n\n![이미지](https://yeaseul7.github.io/neekoBlog/images/softwareAward2.png)\n\n기숙에서 근로를 하던 팀장의 제안에 프로젝트가 이루어졌다.  \n행복 기숙사의 요청을 적극 반영하고 이용자의 연령대를 고려하여  \nUI/UX 에서 중요한 부분을 브리핑 해주었다.\n\n그 요청에 따라서 기술을 React, Styled-compoenet, Next.js 등을 골랐는데  \n당시에는 파일 기반 라우팅으로 인해 디렉토리 구조가 이해하기 쉬웠고  \nTs 적용으로 코드를 보다 이해하기 쉬워 협업에 용이했다.\n\n😇 **아쉬운 점**  \nSEO가 필요하지 않은데 당시 Next.js를 도입한 명확한 이유가 없었다는 점에서 아쉬움이 있다.  \n위와 같이 필요한 기술이 있으면 그 기술을 채택한 이유나 근거가 명확해야 하는데 그 부분이 부족했다.  \n다음에는 명확한 근거를 갖고 기술을 채택할 뿐더러 문서화를 해야겠다고 생각했다.\n\n### 프로젝트 진행\n\n![이미지](https://yeaseul7.github.io/neekoBlog/images/softwareAward3.png)\n피그마와 노션을 이용해서 회의록을 작성하고 피그마로 소통하는 등  \n문서화가 잘 되었던 프로젝트였다고 생각한다.\n\n오류가 있는 부분을 팀 주간 회의에서 브리핑 하고 행복 기숙사의 요청 사항도 기록하여 까먹지 않고 확인할 수 있었다.  \n보통 프로젝트 하고 나서 회고를 작성할 때에도 잘 기억나지 않은 부분이 있는데 노션에 기록이 되어있어서 원활하게 리마인드 할 수 있었다고 생각한다.\n\n😇 **아쉬운 점**\n개인적으로 취준 기간에 프로젝트에 참여하다보니 시간이 많이 부족했다.  \n더 잘 할 수 있었는데 아쉬움이 많이 남았다. 그리고 코드 리뷰나 기술에 대한 분석이 부족했다고 생각한다.  \n좀 더 깃헙 Issue나 PR을 활용했으면 좋았을 것 같다고 생각했다.\n\n웹 사이트 성능을 확인하지 못하고 사용자 경험 개선을 스스로 충분히 고려하지 못했다.  \n단순 기능 개발에 초점을 맞췄다는게 아쉬웠고 앞으로는 사용자 경험 개선을 고려해서 최적화와 같은 분석 및 적용을 해야겠다고 생각했다.\n\n### 프로젝트 결과\n\n![이미지](https://yeaseul7.github.io/neekoBlog/images/softwareAward1.png)\n결과적으로 학교에 도움이 되는 사이트를 만들었고 운영도 되고 있었던 프로젝트였기에 대상을 수상할 수 있었다고 생각한다.  \n기능 개발 보다는 성능을 생각할 수 있게 만들어준 프로젝트였다. 당시에는 생각하지 못했지만 프로젝트를 회고하면서 부족한 부분이 많이 보였고 그만큼 배웠다는 것에 고마운 프로젝트이다.\n\n기술","src/content/docs/retrospect/skhu-contest.mdx","cf7882c850338d1e","secret/gallup_top5",{"id":254,"data":256,"body":261,"filePath":262,"digest":263,"rendered":264},{"title":257,"editUrl":15,"head":258,"template":17,"sidebar":259,"pagefind":15,"draft":19},"Gallup Top 5 CliftonStrengths",[],{"hidden":19,"attrs":260},{},"## 가장 높은 특성 5개\n\n### 절친(Relator) 테마\n\n절친(Relator) 테마는 대인관계에 대한 당신의 태도를 설명해 줍니다.\n간단히 말해, 이 절친(Relator) 테마로 인해 당신은 이미 알고 있는 사람들에게 더 큰 관심을 느낍니다.\n그렇다고 당신이 꼭 새로운 사람을 만나기를 피한다는 뜻은 아닙니다.\n사실 다른 테마의 작용으로 인해 낯선 사람들을 사귀는 것을 무척 좋아할 수도 있습니다. 하지만 당신이 친한 친구들에게서 많은 기쁨과 힘을 얻는 것은 분명합니다. 당신은 친밀함을 편안하게 느낍니다. 따라서 일단 관계가 형성되면, 상대를 더 깊게 알기 위해서 일부러 노력합니다. 당신은 친구들이 느끼는 정서와 두려움, 그리고 추구하는 목표와 꿈을 이해하고 싶어하고, 마찬가지로, 친구들도 당신의 이런 부분을 이해해 주기를 바랍니다. 당신은 이런 종류의 친밀감에 이용 당할 위험이 어느 정도 내포되어 있음을 알고 있습니다. 하지만 그러한 위험을 기꺼이 감수합니다. 당신에게 관계는 진실해야만 가치가 있습니다. 그리고 관계가 진실한지 판단할 수 있는 유일한 방법은 상대방을 믿고 자신을 드러내는 길 밖에는 없습니다. 서로 더 많이 공유할수록, 위험도 더 많이 공유하게 될 것입니다. 이렇게 위험을 함께 감수하는 과정을 거치면서, 각자의 마음이 진실하다는 것이 더 확실히 증명됩니다. 이것이 진정한 우정을 만들어 가는 당신의 절차입 니다. 그리고 당신은 기꺼이 이 절차들을 밟아갑니다.\n\n---\n\n### 최상화(Maximizer) 테마\n\n당신의 기준은 평균이 아니라 최상입니다. 평균 이하를 평균보다 약간 높은 수준으로 끌어올리는 데에는 많은 노력이 소요됩니다. 하지만 이런 개선에 당신은 큰 보람을 느끼지 못합니다. 반면에 우수한 수준을 최상의 수준으로 끌어올리는 데에는 이와 비슷한 노력이 드는데도 불구하고 훨씬 큰 흥미를 느낍니다. 당신은 사람 들의 강점들에 매력을 느낍니다. 그것이 자신의 강점이든 다른 이의 강점이든 말이죠. 마치 진주를 찾는 잠수 부처럼, 당신은 강점을 찾고 강점을 알리는 단서를 예의 주시합니다. 배우지도 않았는데 탁월한 능력을 발휘 한다든지, 배우는 속도가 유난히 빠르다든지 아니면 정식 단계를 밟지 않고도 어떤 기술에 통달한다든지 등 이 강점을 드러내는 단서입니다. 그리고 강점을 발견하면, 당신은 이를 갈고 닦아 최상의 수준으로 끌어올리 고 싶어 합니다. 당신은 진주가 반짝일 때까지 닦고 또 닦습니다. 강점을 찾고 선별하는 성향 때문에 다른 사 람들은 당신이 차별한다고 생각할 수 있습니다. 당신은 본인 특유의 강점을 알아주고 인정해 주는 사람들과 어울리기를 좋아하기 때문입니다. 당신은 자신의 강점을 발견하여 개발한 사람들에게 매력을 느끼는 반면, 부족한 점들을 고쳐서 당신을 평균적인 사람으로 만들려고 하는 사람들은 피하고 싶어 합니다. 자신의 부족 한 점들에 집착해서 평생 한탄하며 살고 싶어하지 않습니다. 그보다는 스스로 타고난 재능을 적극 활용하고 싶어 합니다. 그 편이 훨씬 즐겁고 더 효율적이니까요. 또한 예상과는 다르게 더 많은 노력과 땀이 필요한 길 이기도 합니다.\n\n---\n\n### 발상(Ideation) 테마\n\n당신은 아이디어에 매료되어 있습니다. 아이디어란 무엇일까요? 이는 세상사를 가장 잘 설명해 주는 어떤 원 리나 이념이라고 볼 수 있습니다. 당신은 복잡한 현상의 근본 원인을 설명해 주는 명쾌하고 단순한 원리를 발 견할 때 기쁨을 느낍니다. 아이디어는 연결 고리입니다. 당신은 항상 연결고리를 찾으려 합니다. 그래서 서로 관련이 없어 보이는 별개의 현상들이 눈에 띄지 않는 연결 고리로 연결되어 있음을 발견할 때 흥미를 느낍니 다. 아이디어는 또한 익숙한 문제를 바라보는 새로운 시각입니다. 당신은 우리 모두가 알고 있는 세계를 뒤집 어서 전혀 새로운 각도, 즉 생소한 깨우침을 주는 시각으로 보는 데서 즐거움을 느낍니다. 당신은 이런 모든 종류의 발상과 아이디어들을 사랑합니다. 왜냐하면 이들은 심오하고, 참신하고, 엉뚱하며 기존과는 다른 시 각과 명확성을 제공하기 때문이지요. 이런 모든 이유로 인해, 당신은 새로운 아이디어가 떠오를 때마다 기운 이 샘솟는 것을 느낍니다. 사람들은 당신이 \"창의적이다\", \"독창적이다\", \"발상력이 풍부하다\" 또는 \"똑똑하 다\"고 표현할 수도 있습니다. 어쩌면 당신은 이 모두에 해당될 수도 있습니다. 어느 누가 확신할 수 있겠습니 까? 하지만 확실한 것 하나는 아이디어가 당신을 신바람 나게 만든다는 점입니다. 이것만으로 당신은 만족합니다.\n\n---\n\n### 미래지향(Futuristic) 테마\n\n미래가 이러이러하면 좋지 않을까? 당신은 당면한 현실 너머를 바라보기를 무척 좋아하는 사람입니다. 당신 은 미래에 매혹됩니다. 마치 벽에 투사되는 그림을 보는 것처럼, 당신의 눈에는 미래가 어떨지 상세하게 보입 니다. 이 상세한 그림에 끌려 당신은 앞을 향해, 내일을 향해 나아갑니다. 그림의 구체적인 내용은 당신이 가 진 다른 강점들과 관심사에 따라 달라지겠지만, 이 그림은 언제나 당신에게 더 좋은 제품, 더 훌륭한 팀, 더 행복한 인생, 혹은 더 나은 세상 등에 대한 영감을 줍니다. 당신은 미래의 가능한 모습을 꿈꾸는 사람이며 이러한 비전을 소중히 여깁니다. 현재 상황이 너무 힘들고, 주변 사람들이 너무 현실에만 치중할 때면, 당신은 미래에 대한 비전을 떠올려 보는 방법으로 기운을 냅니다. 이런 당신의 비전은 다른 이들에게도 활력을 줄 수 있습니다. 사실, 사람들은 당신이 미래에 대한 비전을 이야기해 주기를 자주 기대합니다. 그들은 희망과 활기 를 얻을 수 있는 청사진을 원합니다. 당신은 그들에게 이런 비전을 제공해줄 수 있습니다. 연습하십시오. 단 어를 신중히 선택하고, 비전이 최대한 생생하게 전달 될 수 있도록 하십시오. 사람들은 당신이 가져다 주는 희망을 품고 싶어할 것입니다.\n\n---\n\n### 책임(Responsibility) 테마\n\n책임(Responsibility) 테마를 가진 당신은 하겠다고 한 것은 끝까지 책임지려고 합니다. 큰 일이든 작은 일이 든 일단 약속한 것에 대해서는 이를 이행해야 한다는 의무감을 느낍니다. 당신은 자신의 평판이 여기에 달려 있다고 봅니다. 그리고 어떤 이유로든 책임을 이행하지 못하면, 자동적으로 상대방에게 보상할 방법을 찾기 시작합니다. 사과로는 충분하지 않습니다. 변명하고 합리화하는 것은 절대로 용납할 수 없습니다. 만회하고 보상할 때까지 직성이 풀리지 않습니다. 이러한 성실성, 일을 제대로 해야 한다는 강력한 의식, 완전무결한 윤리관 때문에 당신은 \"절대적으로 믿을 수 있는 사람\"이라는 평을 듣습니다. 새로 임무를 맡길 때, 사람들은 제일 먼저 당신을 찾아옵니다. 당신이 그것을 완수해 줄 적임자임을 알고 있기 때문입니다. 가까운 미래에 도 움을 청하러 오는 사람들이 있을 것입니다. 이렇게 도움을 청하러 왔을 때, 당신은 반드시 선별해서 책임을 맡아야 합니다. 그러지 않는다면, 도와주고 싶은 마음에 이끌려 감당할 수 없을 만큼 너무 많은 일을 떠맡게 될지도 모르니까요.","src/content/docs/secret/gallup_top5.md","678cbb066c6407c7",{"html":265,"metadata":266},"\u003Cdiv class=\"sl-heading-wrapper level-h2\">\u003Ch2 id=\"가장-높은-특성-5개\">가장 높은 특성 5개\u003C/h2>\u003Ca class=\"sl-anchor-link\" href=\"#가장-높은-특성-5개\">\u003Cspan aria-hidden=\"true\" class=\"sl-anchor-icon\">\u003Csvg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\u003Cpath fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\">\u003C/path>\u003C/svg>\u003C/span>\u003Cspan class=\"sr-only\">Section titled “가장 높은 특성 5개”\u003C/span>\u003C/a>\u003C/div>\n\u003Cdiv class=\"sl-heading-wrapper level-h3\">\u003Ch3 id=\"절친relator-테마\">절친(Relator) 테마\u003C/h3>\u003Ca class=\"sl-anchor-link\" href=\"#절친relator-테마\">\u003Cspan aria-hidden=\"true\" class=\"sl-anchor-icon\">\u003Csvg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\u003Cpath fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\">\u003C/path>\u003C/svg>\u003C/span>\u003Cspan class=\"sr-only\">Section titled “절친(Relator) 테마”\u003C/span>\u003C/a>\u003C/div>\n\u003Cp>절친(Relator) 테마는 대인관계에 대한 당신의 태도를 설명해 줍니다.\n간단히 말해, 이 절친(Relator) 테마로 인해 당신은 이미 알고 있는 사람들에게 더 큰 관심을 느낍니다.\n그렇다고 당신이 꼭 새로운 사람을 만나기를 피한다는 뜻은 아닙니다.\n사실 다른 테마의 작용으로 인해 낯선 사람들을 사귀는 것을 무척 좋아할 수도 있습니다. 하지만 당신이 친한 친구들에게서 많은 기쁨과 힘을 얻는 것은 분명합니다. 당신은 친밀함을 편안하게 느낍니다. 따라서 일단 관계가 형성되면, 상대를 더 깊게 알기 위해서 일부러 노력합니다. 당신은 친구들이 느끼는 정서와 두려움, 그리고 추구하는 목표와 꿈을 이해하고 싶어하고, 마찬가지로, 친구들도 당신의 이런 부분을 이해해 주기를 바랍니다. 당신은 이런 종류의 친밀감에 이용 당할 위험이 어느 정도 내포되어 있음을 알고 있습니다. 하지만 그러한 위험을 기꺼이 감수합니다. 당신에게 관계는 진실해야만 가치가 있습니다. 그리고 관계가 진실한지 판단할 수 있는 유일한 방법은 상대방을 믿고 자신을 드러내는 길 밖에는 없습니다. 서로 더 많이 공유할수록, 위험도 더 많이 공유하게 될 것입니다. 이렇게 위험을 함께 감수하는 과정을 거치면서, 각자의 마음이 진실하다는 것이 더 확실히 증명됩니다. 이것이 진정한 우정을 만들어 가는 당신의 절차입 니다. 그리고 당신은 기꺼이 이 절차들을 밟아갑니다.\u003C/p>\n\u003Chr>\n\u003Cdiv class=\"sl-heading-wrapper level-h3\">\u003Ch3 id=\"최상화maximizer-테마\">최상화(Maximizer) 테마\u003C/h3>\u003Ca class=\"sl-anchor-link\" href=\"#최상화maximizer-테마\">\u003Cspan aria-hidden=\"true\" class=\"sl-anchor-icon\">\u003Csvg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\u003Cpath fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\">\u003C/path>\u003C/svg>\u003C/span>\u003Cspan class=\"sr-only\">Section titled “최상화(Maximizer) 테마”\u003C/span>\u003C/a>\u003C/div>\n\u003Cp>당신의 기준은 평균이 아니라 최상입니다. 평균 이하를 평균보다 약간 높은 수준으로 끌어올리는 데에는 많은 노력이 소요됩니다. 하지만 이런 개선에 당신은 큰 보람을 느끼지 못합니다. 반면에 우수한 수준을 최상의 수준으로 끌어올리는 데에는 이와 비슷한 노력이 드는데도 불구하고 훨씬 큰 흥미를 느낍니다. 당신은 사람 들의 강점들에 매력을 느낍니다. 그것이 자신의 강점이든 다른 이의 강점이든 말이죠. 마치 진주를 찾는 잠수 부처럼, 당신은 강점을 찾고 강점을 알리는 단서를 예의 주시합니다. 배우지도 않았는데 탁월한 능력을 발휘 한다든지, 배우는 속도가 유난히 빠르다든지 아니면 정식 단계를 밟지 않고도 어떤 기술에 통달한다든지 등 이 강점을 드러내는 단서입니다. 그리고 강점을 발견하면, 당신은 이를 갈고 닦아 최상의 수준으로 끌어올리 고 싶어 합니다. 당신은 진주가 반짝일 때까지 닦고 또 닦습니다. 강점을 찾고 선별하는 성향 때문에 다른 사 람들은 당신이 차별한다고 생각할 수 있습니다. 당신은 본인 특유의 강점을 알아주고 인정해 주는 사람들과 어울리기를 좋아하기 때문입니다. 당신은 자신의 강점을 발견하여 개발한 사람들에게 매력을 느끼는 반면, 부족한 점들을 고쳐서 당신을 평균적인 사람으로 만들려고 하는 사람들은 피하고 싶어 합니다. 자신의 부족 한 점들에 집착해서 평생 한탄하며 살고 싶어하지 않습니다. 그보다는 스스로 타고난 재능을 적극 활용하고 싶어 합니다. 그 편이 훨씬 즐겁고 더 효율적이니까요. 또한 예상과는 다르게 더 많은 노력과 땀이 필요한 길 이기도 합니다.\u003C/p>\n\u003Chr>\n\u003Cdiv class=\"sl-heading-wrapper level-h3\">\u003Ch3 id=\"발상ideation-테마\">발상(Ideation) 테마\u003C/h3>\u003Ca class=\"sl-anchor-link\" href=\"#발상ideation-테마\">\u003Cspan aria-hidden=\"true\" class=\"sl-anchor-icon\">\u003Csvg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\u003Cpath fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\">\u003C/path>\u003C/svg>\u003C/span>\u003Cspan class=\"sr-only\">Section titled “발상(Ideation) 테마”\u003C/span>\u003C/a>\u003C/div>\n\u003Cp>당신은 아이디어에 매료되어 있습니다. 아이디어란 무엇일까요? 이는 세상사를 가장 잘 설명해 주는 어떤 원 리나 이념이라고 볼 수 있습니다. 당신은 복잡한 현상의 근본 원인을 설명해 주는 명쾌하고 단순한 원리를 발 견할 때 기쁨을 느낍니다. 아이디어는 연결 고리입니다. 당신은 항상 연결고리를 찾으려 합니다. 그래서 서로 관련이 없어 보이는 별개의 현상들이 눈에 띄지 않는 연결 고리로 연결되어 있음을 발견할 때 흥미를 느낍니 다. 아이디어는 또한 익숙한 문제를 바라보는 새로운 시각입니다. 당신은 우리 모두가 알고 있는 세계를 뒤집 어서 전혀 새로운 각도, 즉 생소한 깨우침을 주는 시각으로 보는 데서 즐거움을 느낍니다. 당신은 이런 모든 종류의 발상과 아이디어들을 사랑합니다. 왜냐하면 이들은 심오하고, 참신하고, 엉뚱하며 기존과는 다른 시 각과 명확성을 제공하기 때문이지요. 이런 모든 이유로 인해, 당신은 새로운 아이디어가 떠오를 때마다 기운 이 샘솟는 것을 느낍니다. 사람들은 당신이 “창의적이다”, “독창적이다”, “발상력이 풍부하다” 또는 “똑똑하 다”고 표현할 수도 있습니다. 어쩌면 당신은 이 모두에 해당될 수도 있습니다. 어느 누가 확신할 수 있겠습니 까? 하지만 확실한 것 하나는 아이디어가 당신을 신바람 나게 만든다는 점입니다. 이것만으로 당신은 만족합니다.\u003C/p>\n\u003Chr>\n\u003Cdiv class=\"sl-heading-wrapper level-h3\">\u003Ch3 id=\"미래지향futuristic-테마\">미래지향(Futuristic) 테마\u003C/h3>\u003Ca class=\"sl-anchor-link\" href=\"#미래지향futuristic-테마\">\u003Cspan aria-hidden=\"true\" class=\"sl-anchor-icon\">\u003Csvg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\u003Cpath fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\">\u003C/path>\u003C/svg>\u003C/span>\u003Cspan class=\"sr-only\">Section titled “미래지향(Futuristic) 테마”\u003C/span>\u003C/a>\u003C/div>\n\u003Cp>미래가 이러이러하면 좋지 않을까? 당신은 당면한 현실 너머를 바라보기를 무척 좋아하는 사람입니다. 당신 은 미래에 매혹됩니다. 마치 벽에 투사되는 그림을 보는 것처럼, 당신의 눈에는 미래가 어떨지 상세하게 보입 니다. 이 상세한 그림에 끌려 당신은 앞을 향해, 내일을 향해 나아갑니다. 그림의 구체적인 내용은 당신이 가 진 다른 강점들과 관심사에 따라 달라지겠지만, 이 그림은 언제나 당신에게 더 좋은 제품, 더 훌륭한 팀, 더 행복한 인생, 혹은 더 나은 세상 등에 대한 영감을 줍니다. 당신은 미래의 가능한 모습을 꿈꾸는 사람이며 이러한 비전을 소중히 여깁니다. 현재 상황이 너무 힘들고, 주변 사람들이 너무 현실에만 치중할 때면, 당신은 미래에 대한 비전을 떠올려 보는 방법으로 기운을 냅니다. 이런 당신의 비전은 다른 이들에게도 활력을 줄 수 있습니다. 사실, 사람들은 당신이 미래에 대한 비전을 이야기해 주기를 자주 기대합니다. 그들은 희망과 활기 를 얻을 수 있는 청사진을 원합니다. 당신은 그들에게 이런 비전을 제공해줄 수 있습니다. 연습하십시오. 단 어를 신중히 선택하고, 비전이 최대한 생생하게 전달 될 수 있도록 하십시오. 사람들은 당신이 가져다 주는 희망을 품고 싶어할 것입니다.\u003C/p>\n\u003Chr>\n\u003Cdiv class=\"sl-heading-wrapper level-h3\">\u003Ch3 id=\"책임responsibility-테마\">책임(Responsibility) 테마\u003C/h3>\u003Ca class=\"sl-anchor-link\" href=\"#책임responsibility-테마\">\u003Cspan aria-hidden=\"true\" class=\"sl-anchor-icon\">\u003Csvg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\u003Cpath fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\">\u003C/path>\u003C/svg>\u003C/span>\u003Cspan class=\"sr-only\">Section titled “책임(Responsibility) 테마”\u003C/span>\u003C/a>\u003C/div>\n\u003Cp>책임(Responsibility) 테마를 가진 당신은 하겠다고 한 것은 끝까지 책임지려고 합니다. 큰 일이든 작은 일이 든 일단 약속한 것에 대해서는 이를 이행해야 한다는 의무감을 느낍니다. 당신은 자신의 평판이 여기에 달려 있다고 봅니다. 그리고 어떤 이유로든 책임을 이행하지 못하면, 자동적으로 상대방에게 보상할 방법을 찾기 시작합니다. 사과로는 충분하지 않습니다. 변명하고 합리화하는 것은 절대로 용납할 수 없습니다. 만회하고 보상할 때까지 직성이 풀리지 않습니다. 이러한 성실성, 일을 제대로 해야 한다는 강력한 의식, 완전무결한 윤리관 때문에 당신은 “절대적으로 믿을 수 있는 사람”이라는 평을 듣습니다. 새로 임무를 맡길 때, 사람들은 제일 먼저 당신을 찾아옵니다. 당신이 그것을 완수해 줄 적임자임을 알고 있기 때문입니다. 가까운 미래에 도 움을 청하러 오는 사람들이 있을 것입니다. 이렇게 도움을 청하러 왔을 때, 당신은 반드시 선별해서 책임을 맡아야 합니다. 그러지 않는다면, 도와주고 싶은 마음에 이끌려 감당할 수 없을 만큼 너무 많은 일을 떠맡게 될지도 모르니까요.\u003C/p>",{"headings":267,"localImagePaths":288,"remoteImagePaths":289,"frontmatter":290,"imagePaths":292},[268,272,276,279,282,285],{"depth":269,"slug":270,"text":271},2,"가장-높은-특성-5개","가장 높은 특성 5개",{"depth":273,"slug":274,"text":275},3,"절친relator-테마","절친(Relator) 테마",{"depth":273,"slug":277,"text":278},"최상화maximizer-테마","최상화(Maximizer) 테마",{"depth":273,"slug":280,"text":281},"발상ideation-테마","발상(Ideation) 테마",{"depth":273,"slug":283,"text":284},"미래지향futuristic-테마","미래지향(Futuristic) 테마",{"depth":273,"slug":286,"text":287},"책임responsibility-테마","책임(Responsibility) 테마",[],[],{"title":257,"layout":291,"nocomment":15},"../../../layouts/BlogPost.astro",[],"secret/interview",{"id":293,"data":295,"body":300,"filePath":301,"digest":302,"rendered":303},{"title":296,"editUrl":15,"head":297,"template":17,"sidebar":298,"pagefind":15,"draft":19},"인터뷰 스킬",[],{"hidden":19,"attrs":299},{},"### 상대방을 설득하는 나만의 노하우\n\n어떤 이슈가 있어서 회의를 할 때, 먼저 상대방이 하는 이야기를 잘 들어요.\n\n상대방을 설득할때는 공식문서의 자료나, 성능이라던지 이런 지표를 기반으로 근거있는 설득을 지향합니다.\n\n### 능동적, 책임감\n\n1년간 재직했던 스타트업에서 6개월간 근무하며 사원에서 임원으로 승진한 경험이 있으며,\n\nSK11번가에서 2년 넘는 기간동안 풀재택근무를 하였지만 2021년도에 스페셜 리텐션을 받을정도로 자유로운 환경에서 책임감있고 성실하게 일합니다.\n\n### 일정\n - 먼저 jira를 사용해왔는데, 기능별로 due date 산정을 해서 일정을 정하고 협의합니다.\n - 비즈니스를 이유로 피할 수 없는 일정이라면, SK11번가 아마존 프로젝트를 했던 때 처럼, 야근과 주말근무는 피할 수 없는 것 같습니다. 데드라인이 빡빡해도 끝까지 해내는 성격입니다.\n\n### 내 강점?\n - 중견기업에서 인턴, 15명 규모의 스타트업에서 리드 개발자 & 기술면접관, SK11번가에서 핵심 프로젝트 리딩 & 기술면접관을 하고, 카카오스타일에서 재직했던 경험등 다양한 규모의 조직 경험이 있습니다.\n - 테스트코드 열심히 작성합니다. 익숙해져서 나름 빠르고 효율적으로 개발합니다.\n - SK11번가 아마존을 개발할때 넓은 범위의 인앱 웹뷰를 개발했었습니다. 경험과 노하우가 개발팀에서 도움이 될 것 같습니다.\n - 다른 팀의 일도 줄여줄 수 있으면 줄여주려고 노력합니다. 예를 들면, 11번가 아마존 풀 웹뷰.\n - 솔직한 comm. 을 지향합니다.\n    - 솔직하면서도 조심스럽게 커뮤니케이션하는게 제 강점이라고 생각합니다.\n    - 충돌이 있더라도 상대방의 기분을 나쁘지않게 말할 수 있고, 솔직하고 근거 있는 논의로 더 나은결과를 만들어내고 싶어합니다.\n- 사용자의 관점에서 개발\n    - 프론트엔드 개발자는 사용자가 눈으로 보는 화면을 구성합니다.\n    - 사용자의 입장에서 불편함 없는 서비스를 개발하려고 노력합니다.\n\n### 단점\n\n- 개발문서정도는 읽을 수 있지만 다소 취약한 영어.\n- 부끄러움이 많고 긴장을 잘 하는 편.","src/content/docs/secret/interview.md","b8bd530acc39af32",{"html":304,"metadata":305},"\u003Cdiv class=\"sl-heading-wrapper level-h3\">\u003Ch3 id=\"상대방을-설득하는-나만의-노하우\">상대방을 설득하는 나만의 노하우\u003C/h3>\u003Ca class=\"sl-anchor-link\" href=\"#상대방을-설득하는-나만의-노하우\">\u003Cspan aria-hidden=\"true\" class=\"sl-anchor-icon\">\u003Csvg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\u003Cpath fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\">\u003C/path>\u003C/svg>\u003C/span>\u003Cspan class=\"sr-only\">Section titled “상대방을 설득하는 나만의 노하우”\u003C/span>\u003C/a>\u003C/div>\n\u003Cp>어떤 이슈가 있어서 회의를 할 때, 먼저 상대방이 하는 이야기를 잘 들어요.\u003C/p>\n\u003Cp>상대방을 설득할때는 공식문서의 자료나, 성능이라던지 이런 지표를 기반으로 근거있는 설득을 지향합니다.\u003C/p>\n\u003Cdiv class=\"sl-heading-wrapper level-h3\">\u003Ch3 id=\"능동적-책임감\">능동적, 책임감\u003C/h3>\u003Ca class=\"sl-anchor-link\" href=\"#능동적-책임감\">\u003Cspan aria-hidden=\"true\" class=\"sl-anchor-icon\">\u003Csvg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\u003Cpath fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\">\u003C/path>\u003C/svg>\u003C/span>\u003Cspan class=\"sr-only\">Section titled “능동적, 책임감”\u003C/span>\u003C/a>\u003C/div>\n\u003Cp>1년간 재직했던 스타트업에서 6개월간 근무하며 사원에서 임원으로 승진한 경험이 있으며,\u003C/p>\n\u003Cp>SK11번가에서 2년 넘는 기간동안 풀재택근무를 하였지만 2021년도에 스페셜 리텐션을 받을정도로 자유로운 환경에서 책임감있고 성실하게 일합니다.\u003C/p>\n\u003Cdiv class=\"sl-heading-wrapper level-h3\">\u003Ch3 id=\"일정\">일정\u003C/h3>\u003Ca class=\"sl-anchor-link\" href=\"#일정\">\u003Cspan aria-hidden=\"true\" class=\"sl-anchor-icon\">\u003Csvg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\u003Cpath fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\">\u003C/path>\u003C/svg>\u003C/span>\u003Cspan class=\"sr-only\">Section titled “일정”\u003C/span>\u003C/a>\u003C/div>\n\u003Cul>\n\u003Cli>먼저 jira를 사용해왔는데, 기능별로 due date 산정을 해서 일정을 정하고 협의합니다.\u003C/li>\n\u003Cli>비즈니스를 이유로 피할 수 없는 일정이라면, SK11번가 아마존 프로젝트를 했던 때 처럼, 야근과 주말근무는 피할 수 없는 것 같습니다. 데드라인이 빡빡해도 끝까지 해내는 성격입니다.\u003C/li>\n\u003C/ul>\n\u003Cdiv class=\"sl-heading-wrapper level-h3\">\u003Ch3 id=\"내-강점\">내 강점?\u003C/h3>\u003Ca class=\"sl-anchor-link\" href=\"#내-강점\">\u003Cspan aria-hidden=\"true\" class=\"sl-anchor-icon\">\u003Csvg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\u003Cpath fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\">\u003C/path>\u003C/svg>\u003C/span>\u003Cspan class=\"sr-only\">Section titled “내 강점?”\u003C/span>\u003C/a>\u003C/div>\n\u003Cul>\n\u003Cli>중견기업에서 인턴, 15명 규모의 스타트업에서 리드 개발자 &#x26; 기술면접관, SK11번가에서 핵심 프로젝트 리딩 &#x26; 기술면접관을 하고, 카카오스타일에서 재직했던 경험등 다양한 규모의 조직 경험이 있습니다.\u003C/li>\n\u003Cli>테스트코드 열심히 작성합니다. 익숙해져서 나름 빠르고 효율적으로 개발합니다.\u003C/li>\n\u003Cli>SK11번가 아마존을 개발할때 넓은 범위의 인앱 웹뷰를 개발했었습니다. 경험과 노하우가 개발팀에서 도움이 될 것 같습니다.\u003C/li>\n\u003Cli>다른 팀의 일도 줄여줄 수 있으면 줄여주려고 노력합니다. 예를 들면, 11번가 아마존 풀 웹뷰.\u003C/li>\n\u003Cli>솔직한 comm. 을 지향합니다.\n\u003Cul>\n\u003Cli>솔직하면서도 조심스럽게 커뮤니케이션하는게 제 강점이라고 생각합니다.\u003C/li>\n\u003Cli>충돌이 있더라도 상대방의 기분을 나쁘지않게 말할 수 있고, 솔직하고 근거 있는 논의로 더 나은결과를 만들어내고 싶어합니다.\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>사용자의 관점에서 개발\n\u003Cul>\n\u003Cli>프론트엔드 개발자는 사용자가 눈으로 보는 화면을 구성합니다.\u003C/li>\n\u003Cli>사용자의 입장에서 불편함 없는 서비스를 개발하려고 노력합니다.\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003C/ul>\n\u003Cdiv class=\"sl-heading-wrapper level-h3\">\u003Ch3 id=\"단점\">단점\u003C/h3>\u003Ca class=\"sl-anchor-link\" href=\"#단점\">\u003Cspan aria-hidden=\"true\" class=\"sl-anchor-icon\">\u003Csvg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\u003Cpath fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\">\u003C/path>\u003C/svg>\u003C/span>\u003Cspan class=\"sr-only\">Section titled “단점”\u003C/span>\u003C/a>\u003C/div>\n\u003Cul>\n\u003Cli>개발문서정도는 읽을 수 있지만 다소 취약한 영어.\u003C/li>\n\u003Cli>부끄러움이 많고 긴장을 잘 하는 편.\u003C/li>\n\u003C/ul>",{"headings":306,"localImagePaths":320,"remoteImagePaths":321,"frontmatter":322,"imagePaths":323},[307,310,313,315,318],{"depth":273,"slug":308,"text":309},"상대방을-설득하는-나만의-노하우","상대방을 설득하는 나만의 노하우",{"depth":273,"slug":311,"text":312},"능동적-책임감","능동적, 책임감",{"depth":273,"slug":314,"text":314},"일정",{"depth":273,"slug":316,"text":317},"내-강점","내 강점?",{"depth":273,"slug":319,"text":319},"단점",[],[],{"title":296,"layout":291,"nocomment":15},[],"tip/edit-github-profile",{"id":324,"data":326,"body":331,"filePath":332,"digest":333,"deferredRender":15},{"title":327,"editUrl":15,"head":328,"template":17,"sidebar":329,"pagefind":15,"draft":19},"Github 프로필 꾸미기",[],{"hidden":19,"attrs":330},{},"import { Image } from \"astro:assets\";\nimport profileVisitorImg from \"../../../assets/images/github-profile-edit/profileVisitor.png\";\nimport visitorMdImg from \"../../../assets/images/github-profile-edit/visitorMd.png\";\n\n### github 프로필 방문자 수 추가하기\n\n깃허브 프로필은 내 github repository에 있는 readme.md 파일을 수정하면 된다.\n\n#### 방문자 수를 표기하는 방법\n\n사이트 : https://hits.seeyoufarm.com/\n\n위 사이트에 들어가서 자신의 repository 경로를 입력해준다.\n\n\u003CImage\n  src={profileVisitorImg}\n  alt=\"seeyoufarm 사이트 방문자 수 입력 화면\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n```\nhttps://github.com/yeaseul7\n```\n\n입력하고 나면 아래와 같이 나타난다.\n\n\u003CImage\n  src={visitorMdImg}\n  alt=\"seeyoufarm 사이트에서 생성된 마크다운 코드\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\nmarkdown 코드를 복사해서 readme파일에 붙여넣으면 끝!","src/content/docs/tip/edit-github-profile.mdx","2d2043d1fb4483d8","browser/crosbrowsing",{"id":334,"data":336,"body":341,"filePath":342,"digest":343,"deferredRender":15},{"title":337,"editUrl":15,"head":338,"template":17,"sidebar":339,"pagefind":15,"draft":19},"crosbrowsing",[],{"hidden":19,"attrs":340},{},"import { Image } from \"astro:assets\";\nimport renderImg from \"../../../assets/images/crossbrowsing/render.png\";\nimport renderingEngineImg from \"../../../assets/images/crossbrowsing/renderingEngine.png\";\nimport renderingImg from \"../../../assets/images/crossbrowsing/rendering.png\";\nimport parseImg from \"../../../assets/images/crossbrowsing/parse.png\";\n\n웹 호환성과 웹 표준에 대해서 공부하다가  \n웹 호환성 테스트를 위해 크로스 브라우징 테스트라는게 있는지 알았고  \nBabel과 polyfill로 구현한다는 것을 알았다.\n\n이후에 브라우저가 어떻게 동작하길래 이런 호환성을 맞추는 과정이 필요한지 궁금해서  \n렌더링 엔진 및 브라우저 엔진에 대해 살펴보게 되었다.\n\n### 크로스 브라우징이란?\n\n웹 호환성을 구현하기 위한 기술이다.\n\n호환성을 확인하기 위해서는 https://caniuse.com/ 에서 확인해볼 수 있다.\n\n_여담인데 MS가 IE11보다 오래된 IE는 지원을 중지했고 사용해도 Edge로 사용을 전환할것을 요구한다고 한다._\n\n### 렌더링 엔진이란?\n\n화면에 text와 image를 그리는 software이다.  \nHTML,XML,CSS 등 소스 코드를 호출시에 읽고 해석하는 인터프리터이다.\n\n렌더링 엔진은 그릴 때 웹 표준에 따라 보안정책을 강제하며 script에 노출되는 DOM 자료구조를 구현한다.\n\n여기서 보안정책은 사이트 간 스크립팅(XSS), 클릭재킹, 코드 인젝션을 방지한 컴퓨터 보안수준이다.  \n이는 W3C에서 규정하고 있다.\n\n#### 렌더링 엔진 동작 과정\n\nURL을 입력하면 8KB 단위로 문서의 내용이 전달된다.\n이후 아래의 단계로 작업이 진행된다.\n\n1. DOM 트리 구축을 위한 HTML 파싱\n2. 렌더 트리 구축\n3. 렌더 트리 배치\n4. 렌더 트리 그리기\n\n\u003CImage\n  src={renderImg}\n  alt=\"렌더링 엔진 동작 과정\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n여기서 렌더링 엔진은 모든 HTML을 파싱(분석)할 때까지 기다리지 않고 배치와 그리기 과정을 반복한다.  \n즉, 모든 내용을 받기 전 일부 내용을 화면에 표시한다.\n\n#### 렌더링 엔진의 종류\n\n\u003CImage\n  src={renderingEngineImg}\n  alt=\"렌더링 엔진의 종류\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n이중에서 Webkit과 Gecko의 동작 과정은 아래와 같다.\n\n\u003CImage\n  src={renderingImg}\n  alt=\"Webkit과 Gecko의 동작 과정\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\nDOM 구축과 렌더트리를 그리는 과정을 더 자세히 볼 수 있다.\n\n파싱이라는 말이 자주 나오는데  \n파싱도 공부하면 엄청 심오하다.\n\n**파싱은 구문석이다.**\n\n즉, 문서 파싱은 렌더링 측면에서 브라우저가 코드를 이해하고 사용할 수 있는 구조로 만드는 것을 의미한다.  \n크게 두가지로 나눌 수 있다.\n\n1. 어휘 분석\n2. 구문 분석\n\n**어휘분석**\n\n자료를 토큰으로 분해한 것이다.  \n토근은 공백과 줄바꿈 같은 의미 없는 문자를 제거한 유효하게 구성된 단위의 집합체이다.  \n예를 들면 용어집이라고 생각할 수 있다.\n\n**구문 분석**\n\n언어의 구문 규칙을 적용하는 과정이다.\n\n파싱 과정을 아래와 같이 설명할 수 있다.\n\n\u003CImage\n  src={parseImg}\n  alt=\"파싱 과정\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n파싱 트리를 만들고 컴파일러가 기계 코드 문서로 변환하는 과정을 거친다.  \n이 과정에서 **문맥 자유 문법**을 사용한다.\n\n_문맥 자유 문법은 컴파일러 설계나 자연어 처리할 때 언어의 구문을 기술하는데 활용되는 문법이다._\n\n간단히 파싱이 뭔지 알았으니  \n이렇게 파싱이 트리를 구성하고 DOM 트리나 콘텐츠 모델이 완성되는 과정을 더 자세히 이해했을 것이다.\n\n---\n\n네이버 Dev 문서를 적극 차용해서 작성된 글이다.  \n파싱에 대한 내용이 많아서 그 부분은 따로 포스팅을 작성하려고 한다.  \n오늘 포스팅을 위해 문서와 다양한 참고 자료를 3일동안 중간 중간 몇번이나 읽어보고 그곳의 이미지를 차용해 내가 이해한 내용을 붙여서 작성하였다.\nhttps://d2.naver.com/helloworld/59361","src/content/docs/browser/crosbrowsing.mdx","19546416250aad8f","browser/virtual-dom",{"id":344,"data":346,"body":351,"filePath":352,"digest":353,"deferredRender":15},{"title":347,"editUrl":15,"head":348,"template":17,"sidebar":349,"pagefind":15,"draft":19},"Virtual Dom",[],{"hidden":19,"attrs":350},{},"import { Image } from \"astro:assets\";\nimport domtreeImg from \"../../../assets/images/virtual-dom/domtree.png\";\nimport domWebpImg from \"../../../assets/images/virtual-dom/Dom.webp\";\n\n\u003CImage\n  src={domtreeImg}\n  alt=\"DOM 트리 구조\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\", \"png\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\n### DOM이란?\n\n**Document Object Model**\n\nHTML, XML 문서의 프로그래밍 interface다.  \nDOM의 element는 object로 구성되어있다.\n\n_interface란?_\n_사용자가 상호작용 할 수 있게 하는 프로그래밍 인터페이스이다._\n\n즉, DOM은 동적 콘텐츠를 제공하며 사용자로 하여금 상호작용할 수 있게 한다.\n\nDOM이 있기 때문에 javascript와 같은 script언어로 문서의 구조, 스타일 등을 조작할 수 있다.\n\nDOM중에서 최상위에 있는 Document object는 document(웹페이지) 그 자체이다.  \npage content는 DOM에 저장되는데 이걸 script언어로 조작할 수 있다.\n\nDOM API는 DOM을 script 언어로 조작할 수 있도록 제공되는 일련의 인터페이스이다.  \n이것을 이용해서 동적으로 element를 조작할 수 있다.\n\n---\n\n### 그렇다면 React의 Virtual Dom은 무엇인가?\n\n\u003CImage\n  src={domWebpImg}\n  alt=\"Virtual DOM과 Real DOM 비교\"\n  widths={[640, 1280]}\n  sizes=\"(max-width: 640px) 100vw, 640px\"\n  formats={[\"avif\", \"webp\"]}\n  quality={80}\n  loading=\"lazy\"\n  decoding=\"async\"\n/>\n\nVirtual Dom은 **DOM 복사본**이다.  \n이는 실제 DOM이 아닌 JS 객체 형태로 메모리에 저장된다.\n\nVDOM을 통해서 실제 DOM에는 접근할 수 없다. (VDOM을 수정해서 업데이트 한다.)  \nVDOM을 수정하는 것은 메모리에 저장되어있는 JS 객체를 수정하는 것이기 때문에 비교적 가볍다.\n\nVDOM없이 DOM을 조작할 때 스타일을 추가하거나 하면\n\n```javascript\ndocument.querySelector(\"#title\").style.color = \"red\";\n```\n\n1. document에서 해당 element를 탐색해서 찾는다.\n2. 해당 element와 그 자식 element들을 DOM에서 제거한다.\n3. 수정된 Element로 교체한다.\n\n이 과정에서 브라우저의 Reflow와 Repaint를 유발한다.  \n단순히 조금만 수정한다면 문제는 없지만 사이트가 거대해질수록 위의 작업이 반복적으로 일어난다.\n\n---\n\n### React는 VDOM을 이용해서 어떻게 효율적으로 랜더링하나?\n\nReact에서는  \n**랜더링 이전 구조를 나타내는 VDOM**  \n**랜더링 이후에 보일 구조를 나타내는 VDOM**이 존재한다.\n\nReact에서는 State가 변경될 때마다 Re-Rendering이 발생하면서 **랜더링 이후에 보일 구조를 나타내는 VDOM**을 생성한다.  \n그러면 React는 이 두개의 VDOM을 비교해서 어떤 Element가 바뀌었는지 비교한다. **(Diffing)**  \n실제로 바뀐 부분만 실제 DOM에 적용한다. **(Reconciliation)**  \n변경된 모든 내용을 집단화시켜서 한번에 실제 DOM에 적용하는 과정을 거친다. **(Batch Update)**\n\n따라서 훨씬 효율적인 랜더링을 할 수 있다.\n\n참고자료 : https://callmedevmomo.medium.com/virtual-dom-react-%ED%95%B5%EC%8B%AC%EC%A0%95%EB%A6%AC-bfbfcecc4fbb\n\n사진 출처 : https://medium.com/@surksha8/virtual-dom-and-real-dom-understanding-the-differences-da8f3fab4261\n\nhttps://www.freecodecamp.org/news/introduction-to-the-dom/","src/content/docs/browser/virtual-dom.mdx","b0692ec1db998242","secret/mentor",{"id":354,"data":356,"body":361,"filePath":362,"digest":363,"rendered":364},{"title":357,"editUrl":15,"head":358,"template":17,"sidebar":359,"pagefind":15,"draft":19},"멘토링",[],{"hidden":19,"attrs":360},{},"### JS 개발자 면접을 위한 멘토링 자료 정리\n\n- [인터뷰 스킬](/secret/interview)\n\n- [FE 개발자가 되기위한 mdn 학습서](https://developer.mozilla.org/ko/docs/orphaned/Learn/Front-end_web_developer)\n\n- [JS 구성요소](https://developer.mozilla.org/ko/docs/Learn/JavaScript/Building_blocks)","src/content/docs/secret/mentor.md","e2de93cc39fb83e2",{"html":365,"metadata":366},"\u003Cdiv class=\"sl-heading-wrapper level-h3\">\u003Ch3 id=\"js-개발자-면접을-위한-멘토링-자료-정리\">JS 개발자 면접을 위한 멘토링 자료 정리\u003C/h3>\u003Ca class=\"sl-anchor-link\" href=\"#js-개발자-면접을-위한-멘토링-자료-정리\">\u003Cspan aria-hidden=\"true\" class=\"sl-anchor-icon\">\u003Csvg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\u003Cpath fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\">\u003C/path>\u003C/svg>\u003C/span>\u003Cspan class=\"sr-only\">Section titled “JS 개발자 면접을 위한 멘토링 자료 정리”\u003C/span>\u003C/a>\u003C/div>\n\u003Cul>\n\u003Cli>\n\u003Cp>\u003Ca href=\"/secret/interview\">인터뷰 스킬\u003C/a>\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Ca href=\"https://developer.mozilla.org/ko/docs/orphaned/Learn/Front-end_web_developer\">FE 개발자가 되기위한 mdn 학습서\u003C/a>\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Ca href=\"https://developer.mozilla.org/ko/docs/Learn/JavaScript/Building_blocks\">JS 구성요소\u003C/a>\u003C/p>\n\u003C/li>\n\u003C/ul>",{"headings":367,"localImagePaths":371,"remoteImagePaths":372,"frontmatter":373,"imagePaths":374},[368],{"depth":273,"slug":369,"text":370},"js-개발자-면접을-위한-멘토링-자료-정리","JS 개발자 면접을 위한 멘토링 자료 정리",[],[],{"title":357,"layout":291,"nocomment":15},[]]