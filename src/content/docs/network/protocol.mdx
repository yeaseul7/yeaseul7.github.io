---
layout: ../../../layouts/BlogPost.astro
title: Protocol
---

import { Image } from "astro:assets";
import protocolComputeImg from "../../../assets/images/protocol/protocolCompute.png";
import clientImg from "../../../assets/images/protocol/client.png";
import os7Img from "../../../assets/images/protocol/os7.png";
import applicationLayerImg from "../../../assets/images/protocol/applicationLayer.png";
import presentationLayerImg from "../../../assets/images/protocol/presentationLayer.png";
import sessionLayerImg from "../../../assets/images/protocol/sessionLayer.png";
import transportImg from "../../../assets/images/protocol/transport.png";
import networkImg from "../../../assets/images/protocol/network.png";
import dataLinkImg from "../../../assets/images/protocol/dataLink.png";
import pysImg from "../../../assets/images/protocol/pys.png";
import os7LayerImg from "../../../assets/images/protocol/os7Layer.png";
import tcpImg from "../../../assets/images/protocol/tcp.png";
import hand3Img from "../../../assets/images/protocol/3hand.png";
import hand4Img from "../../../assets/images/protocol/4hand.png";

들어가면서.

웹 개발자로 함은 다양한 네트워크 통신으로 인해 화면이 어떻게 그려지는지  
그리고 어떤 방식으로 내가 원하는 데이터가 오고 가는지 이해할 필요가 있다고 생각한다.

그중에서 기초적인 프로토콜과 OSI 7 Layer와 TCP/IP에 대해 먼저 살펴보고자 한다.

먼저 프로토콜이 무엇인지 알아보자.

### 프로토콜

컴퓨터 내부 혹은 컴퓨터 사이에서 데이터 교환 방식을 정의하는 규칙이다.

강아지가 기분이 좋으면 꼬리를 흔들고 경계하면 꼬리를 굳힌다.  
이는 강아지들 사이에서 통하는 규칙이라고 볼 수 있다.  
이처럼 컴퓨터 사이에서도 데이터를 주고 받을 때 규칙이 필요하다.  
안그러면 어떤 컴퓨터는 이해하고 다른 컴퓨터는 이해하지 못하는 상황이 생길 수 있다.

이러한 규칙이 바로 프로토콜이다.

<Image
  src={protocolComputeImg}
  alt="프로토콜 개념도"
  widths={[640, 1280]}
  sizes="(max-width: 640px) 100vw, 640px"
  formats={["avif", "webp", "png"]}
  quality={80}
  loading="lazy"
  decoding="async"
/>

이 프로토콜에도 종류가 있다.  
상태 프로토콜, 무상태 프로토콜  
즉, 기억을 하냐 못하냐의 차이라고 볼 수 있다.

#### 상태 프로토콜(Stateful protocol)

Server side에서 server와 client가 동작한 상태 정보를 저장하는 형태이다.  
이것을 Server의 session에 저장하곤 하는데 이 session 정보에 따라 서버의 응답이 달라진다.  
ex)TCP handshake

#### 무상태 프로토콜(Stateless prorocol)

Server의 응답이 client session 상태와 독립적이며 상태를 저장하지 않는다.  
따라서 항상 요청할 때 필요한 정보를 모두 담아서 보내야 하는 상황이 생긴다.  
ex) UDP/ HTTP

<Image
  src={clientImg}
  alt="상태 프로토콜과 무상태 프로토콜 비교"
  widths={[640, 1280]}
  sizes="(max-width: 640px) 100vw, 640px"
  formats={["avif", "webp", "png"]}
  quality={80}
  loading="lazy"
  decoding="async"
/>

무상태 프로토콜, 상태 프로토콜은 각각 장단점이 존재한다.  
무상태는 서버 사이드에 세션 정보를 저장하지 않는 대신 서버의 자원을 비교적 효율적으로 사용할 수 있다.  
하지만 모든 필요 자원을 담아서 보내야 한다는 전제 하에 보안에 취약하다.  
상태는 반대라고 볼 수 있다.

---

프로토콜이 컴퓨터가 데이터를 주고 받을 때 쓰이는 규칙이라고 했는데, 그 규칙은 어떤 과정에서 필요한걸까?  
바로 데이터를 전송하는 네트워크에서 필요하다.  
이 과정에서 많은 프로토콜이 쓰이는데 이것을 계층적으로 구분지은게 모델이다.

계층적으로 구분지은 이유는 데이터를 한번에 주고 받으면 에러 관리도 힘들고 통신 제어도 힘들다.  
이를 계층을 나누고 역할을 분배하여 처리할 수 있게 한다. 이를 분할 정복(Divide and Conquer)이라고 한다.

대표적으로 OSI 7 Layer 모델과 TCP/IP 모델이 존재한다.

#### OSI7 Layer Model

<Image
  src={os7Img}
  alt="OSI 7 Layer 모델"
  widths={[640, 1280]}
  sizes="(max-width: 640px) 100vw, 640px"
  formats={["avif", "webp", "png"]}
  quality={80}
  loading="lazy"
  decoding="async"
/>

이 모델은 산업 표준 모델이다.  
초창기 네트워크의 표준을 만들기 위해 해당 모델이 나타났다.

**OSI 7 Layer - Application Layer[응용 계층]**

<Image
  src={applicationLayerImg}
  alt="Application Layer 응용 계층"
  widths={[640, 1280]}
  sizes="(max-width: 640px) 100vw, 640px"
  formats={["avif", "webp", "png"]}
  quality={80}
  loading="lazy"
  decoding="async"
/>

소프트웨어가 사용자에게 데이터를 제공하기 위해 의존하는 프로토콜이다.  
이 Layer는 이메일이나 브라우저 같은 소프트웨어 애플리케이션이 통신을 열기 위해 존재한다.

대표적으로 **HTTP, FTP, Telnet, DHCP** 프로토콜이 존재한다.

**OSI 7 Layer - Presentation Layer[표현 계층]**

<Image
  src={presentationLayerImg}
  alt="Presentation Layer 표현 계층"
  widths={[640, 1280]}
  sizes="(max-width: 640px) 100vw, 640px"
  formats={["avif", "webp", "png"]}
  quality={80}
  loading="lazy"
  decoding="async"
/>

데이터를 사용할 수 있게 해주는 계층이다.  
데이터를 사용할 수 있게 암호화, 변환, 압축을 담당한다.  
이렇게 데이터를 변환하는 이유는 수신하는 노드(컴퓨터)가 다른 인코딩 방법을 사용할 수 있기 때문이다.

대표적으로 **ASCII, MPEG, JPEG 프로토콜**이 존재한다.

​

**OSI 7 Layer - Session Layer[세션 계층]**

<Image
  src={sessionLayerImg}
  alt="Session Layer 세션 계층"
  widths={[640, 1280]}
  sizes="(max-width: 640px) 100vw, 640px"
  formats={["avif", "webp", "png"]}
  quality={80}
  loading="lazy"
  decoding="async"
/>

세션이란? 여기서 session은 통신이 시작될 때부터 종료 시점까지를 의미한다.  
따라서 이 계층은 통신 시작과 끝을 결정하는 역할을 하고 리소스를 낭비하지 않게 세션을 개방하고 닫는 등의 역할을 한다.  
데이터를 전송하다가 중간에 끊기면 처음부터 다시 전송을 재개해야하는데  
이 계층에서 체크포인트를 설정해서 그 지점부터 재전송을 할 수 있게 한다.

대표적으로 **SSH, TLS, RPC 프로토콜**이 존재한다.

**OSI 7 Layer - Transport Layer[전송 계층]**

<Image
  src={transportImg}
  alt="Transport Layer 전송 계층"
  widths={[640, 1280]}
  sizes="(max-width: 640px) 100vw, 640px"
  formats={["avif", "webp", "png"]}
  quality={80}
  loading="lazy"
  decoding="async"
/>

세션 계층에서 데이터를 가져와서 세그먼트 단위로 조각내는 역할을 한다.  
연결 속도가 빠른 쪽이 느린쪽을 압도하지 않도록 전송 속도를 조정하기도 한다.  
또한 수신 완료 여부를 파악하고 오류 제어를 수행한다.

**OSI 7 Layer - Network Layer[네트워크 계층]**

<Image
  src={networkImg}
  alt="Network Layer 네트워크 계층"
  widths={[640, 1280]}
  sizes="(max-width: 640px) 100vw, 640px"
  formats={["avif", "webp", "png"]}
  quality={80}
  loading="lazy"
  decoding="async"
/>

전송 계층의 세그먼트를 송신자의 장치에서 패킷 단위로 쪼갠다. 그리고 수신 장치에서 다시 패킷을 조립한다.  
이런 과정을 진행할 수 있게 데이터가 최적의 경로로 이동할 수 있게 라우팅한다.

이 계층은 송신 장치와 수신 장치가 같은 네트워크에 있다면 필요 없다.

대표적으로 **IP, ICMP 프로토콜**이 존재한다.

장비 : 라우터

**OSI 7 Layer - Data Link Layer[데이터 링크 계층]**

<Image
  src={dataLinkImg}
  alt="Data Link Layer 데이터 링크 계층"
  widths={[640, 1280]}
  sizes="(max-width: 640px) 100vw, 640px"
  formats={["avif", "webp", "png"]}
  quality={80}
  loading="lazy"
  decoding="async"
/>

네트워크 계층에서 받은 패킷을 더 작은 프레임으로 세분화한다.  
이 프레임들이 통신하는데에 있어서 흐름과 오류를 제어한다.  
이 계층은 같은 네트워크에 있는 장치들 간의 데이터 전송도 담당한다.

데이터 링크 계층은 머리와 꼬리에 데이터 수신 장치와 송신 장치 주소 등의 정보를 제공한다.  
그 정보는 MAC주소라고 할 수 있다.

MAC : Media Access Control Address

대표적으로 **이더넷(Ethernet), PPP, UART 프로토콜**이 존재한다.

장비 : 스위치, 브릿지

**OSI 7 Layer - Physical Layer[물리 계층]**

<Image
  src={pysImg}
  alt="Physical Layer 물리 계층"
  widths={[640, 1280]}
  sizes="(max-width: 640px) 100vw, 640px"
  formats={["avif", "webp", "png"]}
  quality={80}
  loading="lazy"
  decoding="async"
/>

Hub, router, cable 등 물리 매체를 통해 상위 계층에 전송된 데이터를 다른 시스템에 전기적 신호를 통해 전송하는 계층이다.  
대표적으로 **1000BASE-T, RS-232, RS-485 프로토콜**이 존재한다.

장비 : HUB, 리피터, 모뎀

---

#### TCP/IP 4 계층

TCP는 OSI 7과 다르게 각 계층이 종속적으로 이루어져있다.  
OSI가 있는데 TCP가 또 만들어진 이유는 IP 규칙으로만 통신하기에 불안정 했던 단점들을 커버하기 위함이다.

이는 패킷 전송을 제어해서 신뢰성을 보증한다.

<Image
  src={os7LayerImg}
  alt="TCP/IP 4 계층 모델"
  widths={[640, 1280]}
  sizes="(max-width: 640px) 100vw, 640px"
  formats={["avif", "webp", "png"]}
  quality={80}
  loading="lazy"
  decoding="async"
/>

**TCP-Network Interface Layer[네트워크 인터페이스 계층]**

하드웨어적인 요소와 관련된 모든 것을 지원하는 계층이다.  
물리적인 주소를 지정하고 오류를 감지해낸다.

**TCP - 인터넷 계층**
패킷을 목적지까지 전송하는 역할을 하며 라우팅, 주소 지정, 패킷 포워딩 등을 한다.

**TCP- 전송 계층**
애플리케이션 간에 데이터 흐름과 오류를 제어한다.

이 과정에서 일어나는 TCP 3-Way Handshake와 4-Way Handshake를 알 필요가 있다.

먼저 데이터를 전송하기 전에 연결하는 과정에서 3 Way Handshake가 일어난다.

<Image
  src={tcpImg}
  alt="TCP 3-Way Handshake"
  widths={[640, 1280]}
  sizes="(max-width: 640px) 100vw, 640px"
  formats={["avif", "webp", "png"]}
  quality={80}
  loading="lazy"
  decoding="async"
/>

여기서 SYN는 synchronize sequence numbers ACK는 acknowledgements의 약자이다.

그림대로 3번의 확인 절차를 통해 연결할 준비를 한다.
클라이언트와 서버가 "너 데이터 받을 준비 됐어?" -> "나 준비 완료" -> "나도 준비 완료" 이런 과정을 거친다고 생각하면 된다.

**CLOSED는 닫힌 상태
LISTEN은 요청 대기 상태
SYN-SENT는 SYN 요청 상태
SYN-RECEIVED는 SYN 요청을 받은 상태
ESTABLISHED는 연결 확인 상태 이다.**

그리고 데이터 교환 과정이 일어난다.

<Image
  src={hand3Img}
  alt="TCP 데이터 교환 과정"
  widths={[640, 1280]}
  sizes="(max-width: 640px) 100vw, 640px"
  formats={["avif", "webp", "png"]}
  quality={80}
  loading="lazy"
  decoding="async"
/>

ESTABLISHED 상태에서 데이터를 보내면 송신, 수신측은 전송이 잘 되었다는 의미로 ACK 응답을 보내는데  
이게 안오거나 하면 송신측이 계속 데이터를 보낸다.

데이터를 교환하고 연결 종료 될 때 4 Way Handshake 과정이 일어난다.

<Image
  src={hand4Img}
  alt="TCP 4-Way Handshake"
  widths={[640, 1280]}
  sizes="(max-width: 640px) 100vw, 640px"
  formats={["avif", "webp", "png"]}
  quality={80}
  loading="lazy"
  decoding="async"
/>

이것도 송신측과 수신측이  
"나 이제 다 보냈어"=> "오케 닫을게", "닫았어" => "나도 닫을게" 이렇게 주고 받는다고 이해하면 된다.

_TCP- 응용 계층_
응용 프로그램들이 네트워크를 이용할 수 있게 암호화, 사용자 인증을 수행하는 역할이다.

---

이상으로 TCP와 OSI 7 Layer등 프로토콜과 모델에대해 살펴보았다.

CS 측면에서 모뎀이 무엇인지, HUB가 무엇인지 등을 더 자세히 살펴 볼 필요가 있다.

그리고 TCP 통신과 브라우저 작동과도 연계가 되어있는데

이 부분에 대해서 추후에 리포팅 하겠다.

참고로 같은 내용을 네이버 블로그에서도 다루는 중이다.
https://blog.naver.com/neeko_k/223590184796
