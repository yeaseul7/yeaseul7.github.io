---
title: HTTP & HTTPS
layout: ../../../layouts/BlogPost.astro
---

## HTTP란?

HTML 같은 문서를 가져올 수 있게 하는 Protocol이다.

Network 카테고리에서 매우 많이 본 Protocol 자세한 내용은 블로그를 참고해 주길 바란다.

[프로토콜](https://yeaseul7.github.io/neekoblog/protocol/)

HTTP는 클라이언트와 서버가 서로 통신하기 위해 사용하는 프로토콜이다.
중간에 다른 역할을 하는 개체들도 존재한다

- 게이트웨이(Gateway) : 특정 서버로 가는 트래픽을 관리하는 서버
- 프록시(Proxy) : 서버의 데이터를 캐싱해서 클라이언트와 서버간의 트래픽을 최적화하는 서버

이 두가지에 대해서는 아래에서 다시 설명하겠다.
먼저 Client와 Server의 특징에 대해 알아보자.

### 이때 Client와 Server의 특징은 무엇인가?

- Client : 요청을 보내는 주체
- Server : 요청을 받아서 응답하는 주체

**Client는 서버에 요청을 보내고, 서버는 요청을 받아서 응답을 보낸다.**
주로 클라이언트는 브라우저의 역할을 수행함으로 랜더링을 위해 스크립트와 HTML문서를 요청한다.

**Server는 클라이언트의 요청을 받아서 응답을 보낸다.**
Server는 script를 응답하거나 데이터를 전달하는 역할을 수행한다.

HTTP/1.1 이후 Header의 기능으로 한개의 IP 주소로 여러개의 포트를 사용할 수 있게 되었다.
이는 **가상 호스트(Virtual Host)** 라고 부른다.
주로 일처리가 많은 서버는 여러개의 포트를 사용해서 일처리를 하게 된다.
예를 들어서 DB 서버와 웹 서버가 있을 때 웹 서버는 80번 포트를 사용하고 DB 서버는 3306번 포트를 사용한다.

### 가상 호스트에 대해 더 자세히 짚어보자

같은 IP에서 다른 도메인을 사용해서 분산처리하는 것을 의미한다.
예를 들어서 www.naver.com 과 www.daum.net 이 있을 때 같은 IP 주소를 사용하지만 다른 도메인을 사용해서 분산처리하는 것을 의미한다.

즉, 서버는 가상 호스트를 통해 여러 도매인으로 클라이언트와 통신할 수 있으며 그때 사용하는 프로토콜은 HTTP이다.

프로토콜 포스트에서 설명했지만 HTTP는 Stateless 프로토콜이다.

## Stateful하지 않은 HTTP는 보안을 어떻게 할까?

HTTP는 기본적으로 보안 설정이 되어있지 않다.
하지만 TCP와 TLS를 통해 암호화 하여 HTTPS로 보안을 강화할 수 있다.

### TLS는 무엇인가?

TLS(Transport Layer Security)는 데이터를 암호화하여 보호하는 프로토콜이다.
이것을 이용해 암호화된 HTTP 프로토콜을 HTTPS 프로토콜이라고 부른다.
(암호화 관련하여 TLS 이외에 SSL이라는 프로토콜도 존재한다.
SSL은 TLS의 이전 버전이다.)

HTTP와 HTTPS의 차이는 즉, 보안화된 프로토콜의 차이가 있다고 볼 수 있다.

---

## HTTP

1. HTTP는 Header에 의해 확장성이 높다.
   HTTP는 header의 다양한 옵션을 통해 추가 기능을 구현할 수 있다.

2. Stateless 프로토콜이지만, Cookie를 통해 상태를 유지할 수 있다.
   계속 말했듯이 HTTP는 Stateless 프로토콜이다. 그래서 Cookie를 통해 상태를 유지하곤 하는데, 이 Cookie는 클라이언트에서 데이터를 저장하여 Session을 유지하는 역할을 수행한다.

   - 로그인으로 예시를 들어보자
   - 클라이언트에서 유저가 아이디와 비밀번호를 작성해서 서버에 POST 요청을 보낸다.
   - 서버는 인증 절차를 거친 후 Session ID를 생성하고 HTTP header의 Set-Cookie 옵션을 통해 클라이언트에 전달한다.
   - 클라이언트는 받은 Session ID를 쿠키에 저장한다.
   - 이후 요청시 쿠키에 저장된 Session ID를 함께 전송하여 인증 상태를 유지한다.

3. 데이터 손실을 방지하기 위해 TCP를 신뢰한다.
   TCP는 데이터를 전송하기 전에 3-way handshake를 통해 연결을 설정하고 데이터를 전송한다.
   이는 프로토콜 포스팅에서 설명했다.
   [프로토콜](https://yeaseul7.github.io/neekoblog/protocol/)

   여러 왕복이 필요한 TCP 연결을 설정하기 위해 HTTP/1.0은 기본적으로 요청을 보낼때마다 TCP 연결을 여는 동작을 수행한다.
   이는 여러 요청을 보내는 경우 네트워크 부하가 커지는 문제가 있다.
   이점을 해결하기 위해 HTTP/1.1은 파이프 라이닝 개념을 도입하고 HTTP/2는 멀티플렉싱 개념을 도입하여 네트워크 부하를 줄였다.

---

## HTTP/1.1의 파이프 라이닝 개념

개념은 **'작업이 처리가 된 이후에도 TCP 연결을 유지할 수 있게 하는 것'** 이다.
이걸 **Keep-Alive Connection** 이라고 부른다.

이는 응답을 기다리지 않고 단일 연결을 통해 HTTP 요청을 보내고 있는 것을 확인할 수 있다.
이로인해 요청 처리 속도는 빨라질 수 있지만 순서를 맞춰서 응답하는 부분이 다루기 어렵다.
여러가지 오청을 계속 보낼 수 있어서 속도가 빨라진다는 장점이 있지만 HTTP Header는 요청마다 같은 정보를 담기 때문에 비효울적일 수 있다.
같은 정보를 계속 보내면 보내는 데이터 양이 증가한다는 의미이고 이는 회선 비용을 증가시킨다.
헤더는 패킷에 포함되는데 헤더에 데이터가 쌓인다는 것은 패킷의 양도 증가시킨다는 의미이다.
패킷의 양이 많아지면 PPS가 늘어난다.
(PPS란 초당 처리해야 될 패킷 수를 의미한다.)
이로인해 HTTP/2의 멀티 플랙싱 개념이 도입되었다.

---

## HTTP/2의 멀티 플렉싱 개념

하나의 연결에서 여러 요청과 응답의 순서를 따로 신경쓰지 않는 방법이다.
HTTP/2의 멀티 플렉싱은 PPS가 늘어나는 한계를 해결하기 위해서 도입되었는데 이는 헤더 압축을 이용한 것이다.

헤더는 허프만 코드를 이용하여 압축하는데
이 알고리즘은 회전 양이 많아질수록 유리하다.
관련 포스팅은 별도로 남겨두겠다.
