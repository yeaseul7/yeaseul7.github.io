---
layout: ../../../layouts/BlogPost.astro
title: Prototype
---

import { Image } from "astro:assets";
import constructorPrototypeImg from "../../../assets/images/prototype/contructorprototype.png";
import abnormalChainImg from "../../../assets/images/prototype/abnormal_prototype_chain.png";

### Prototype 기반 OOP

> Javascript는 Prototype으로 OOP 특성인 상속성을 보여준다.

생성자 함수를 사용하여 OOP 특성인 상속성을 구현하면 함수 같은 경우 인스턴스마다 속성이 중복으로 생기기 때문에 메모리 측면에서 비효율적일 수 있다.
이때 prototype으로 한곳에 함수를 저장하고 prototype 접근을 통해 효율적으로 사용할 수 있다.

```javascript
// 생성자 함수를 사용하는 경우
function Circle(radius) {
  this.radius = radius;
  this.getArea = function () {
    return Math.PI * this.radius ** 2;
  };
}

const circle1 = new Circle(1);
const circle2 = new Circle(2);

//getArea가 중복으로 생성됨 🥲

// Prototype을 사용하는 경우

function Circle(radius) {
  this.radius = radius;
}

Circle.prototype.getArea = function () {
  return Math.PI * this.radius ** 2;
};

const circle1 = new Circle(1);
const circle2 = new Circle(2);

//Circle.prototype으로부터 getArea를 상속받는다.
```

모든 객체는 [[Prototype]]이 존재하고 그 값은 null일 수 있다.
객체 생성 방식에 따라 어떤 값이 들어갈지 정해진다.
또한 그 값은 `__proto__`로 간접 접근 가능하다.

### [[Prototype]] & prototype

**`[[Prototype]]`**

- 모든 객체
- `__proto__` 접근자나 `Object.getPrototypeOf()`로 접근 가능
- 상위에 있는 프로토타입 객체
- 함수의 경우 -> `Function.prototype`
- 인스턴스의 경우 -> 생성자 함수의 `prototype` 객체

**`prototype` 프로퍼티**

- 함수 객체만 가지고 있는 일반 프로퍼티
- 인스턴스의 `[[Prototype]]`이 가리킬 객체 `ex) Dog.prototype`
  > ⚠️ 화살표 함수는 non-constructor이기 때문에 prototype 프로퍼티가 없다.

```javascript
function Dog(name) {
  this.name = "early";
}

const puppy = new Dog("access");

console.log(Dog.prototype); // Dog는 함수이므로 prototype 프로퍼티 존재
console.log(puppy.prototype); // undefined

console.log(puppy.__proto__ === Dog.prototype); // true
console.log(Dog.__proto__); // Function.prototype
console.log(puppy.__proto__); // Dog.prototype
```

### `__proto__`

> `__proto__`는 접근자 프로퍼티이다.

`__proto__`는 getter/setter를 통해 [[Prototype]]에 접근할 수 있게 해준다.

```javascript
const obj = {};
const parent = { x: 1 };
// getter 함수인 get __proto__가 호출되어 obj 객체의 프로토타입을 취득
obj.__proto__;
```

```javascript
const obj = {};
const parent = { x: 1 };
// setter 함수인 set __proto__가 호출되어 obj 객체의 프로토타입을 교체
obj.__proto__ = parent;
```

#### `__proto__`를 사용하는 이유

`__proto__`를 사용하지 않으면 비정상적인 프로토타입 체인이 만들어질 수 있다.

```javascript
const parent = {};
const child = {};
// child의 프로토타입을 parent로 설정
child.__proto__ = parent;
// parent의 프로토타입을 child로 설정
parent.__proto__ = child; // TypeError: Cyclic __proto__ value
```

**프로토타입 체인은 Linked List 구조이기 때문에 순환 참조가 발생하면 안된다.**

접근자 프로퍼티를 사용하지 않고 직접 변경하는 방법은 없지만 그렇게 하면 체인을 탐색하는 과정에서 무한루프가 발생할 수 있다.

<Image
  src={abnormalChainImg}
  alt="비정상적인 프로토타입 체인"
  widths={[640, 1280]}
  sizes="(max-width: 640px) 100vw, 640px"
  formats={["avif", "webp", "png"]}
  quality={80}
  loading="lazy"
  decoding="async"
/>

### constructor 프로퍼티

프로토타입 객체는 constructor 프로퍼티를 갖는다.

이 constructor프로퍼티는 객체의 입장에서 자신을 생성한 객체를 가리킨다.

<Image
  src={constructorPrototypeImg}
  alt="constructor 프로퍼티와 prototype 관계"
  widths={[640, 1280]}
  sizes="(max-width: 640px) 100vw, 640px"
  formats={["avif", "webp", "png"]}
  quality={80}
  loading="lazy"
  decoding="async"
/>

> 리터럴 표현 방식으로 만들어진 객체는 추상연산으로 인해 반드시 객체를 생성한 생성자 함수와 연결되지 않을 수 있다.

```javascript
// 1. Object 생성자 함수에 의한 객체 생성
// 인수가 전달되지 않았을 때 추상 연산 OrdinaryObjectCreate를 호출하여 빈 객체를 생성한다.
let obj = new Object();
console.log(obj); // {}

// 2. new.target이 undefined나 Object가 아닌 경우
// 인스턴스 -> Foo.prototype -> Object.prototype 순으로 프로토타입 체인이 생성된다.
class Foo extends Object {}
new Foo(); // Foo {}

// 3. 인수가 전달된 경우에는 인수를 객체로 변환한다.
// Number 객체 생성
obj = new Object(123);
console.log(obj); // Number {123}

// String 객체 생성
obj = new Object("123");
console.log(obj); // String {"123"}
```

모든 객체는 `Object.create(null)`이 아닌이상 내부적으로 생성자 함수를 사용한다.

```javascript
const obj = {};
const obj2 = new Object();
// obj와 obj2는 동일한 프로토타입 체인을 가진다.
```

### ✅ Prototype Chain

객체에서 프로퍼티나 메소드에 접근하려고 할 때 자신에게 해당 속성이 없으면 [[Prototype]]이 가리키는 링크를 따라 탐색한다.
계속 올라가다가 null을 프로토타입으로 가지는 Object를 만나면 그때 프로퍼티 참조를 멈춘다.
이러한 과정을 프로토타입 체인이라고 한다.

```javascript
const early = {
  type: "Dog",
};

console.log(early.hasOwnProperty("type")); // -> true

//early라는 객체는 hasOwnProperty라는 메소드를 가지고 있지 않는데 정상적으로 출력되었다.
//이는 early라는 객체의 [[Prototype]]이 가리키는 링크인 Object.prototype의 hasOwnProperty를 호출하였기 때문이다.
//Object.prototype.hasOwnProperty.call(early, "type")
```

javascript의 Reference Type은 모두 위와 같은 방식으로 동작한다. (ex. Array, Set, Object, Function)
Reference Type은 위의 프로토타입 체인을 통해 내장 메서드에 접근한다. (ex. Array.prototype.map())

_javascript의 Prototype 속성을 이용해서 자료구조에 활용하는 예시를 추후에 추가하고자 한다._

### 📍 프로토타입 체인이 생성되는 경우

1. 객체 리터럴 방식
2. 생성자 함수 방식
3. Object.create()

#### 객체 리터럴 방식

javascript 엔진은 객체 리터럴로 생성하는 코드를 만나면 내부적으로 Object.create(Object.prototype)와 유사한 방식으로 객체를 생성한다.
Object.create()는 함수 객체로 일반 객체와 다르게 prototype 프로퍼티가 있다.

### ⚠️ 주의할 점

Polyfill : 브라우저가 지원하지 않는 최신 기능을 기존의 내장 객체의 프로토타입에 추가하는 코드

```javascript
if (!Array.prototype.includes) {
  Array.prototype.includes = function (value) {
    return this.indexOf(value) !== -1;
  };
}
```

Ponyfill : Polyfill과 비슷하지만 내장 객체를 직접 수정하지 않고 독립적인 함수로 제공하는 방법

```javascript
function includes(array, value) {
  return array.indexOf(value) !== -1;
}

includes([1, 2, 3], 2); // true
```

위의 두가지를 사용하는 경우가 아니라면 네이티브 프로토타입을 확장하면 캡슐화를 망친다.
(Monkey Patching: 기존의 객체나 함수의 동작을 런타임에 직접 수정하거나 덮어쓰는 것)
