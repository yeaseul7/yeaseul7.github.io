---
layout: ../../../layouts/BlogPost.astro
title: V8 Bytecode
---

import { Image } from "astro:assets";
import jspipelineImg from "../../../assets/images/v8bytecode/jspopeline.webp";
import ldaSmiImg from "../../../assets/images/v8bytecode/LdaSmi[1].webp";
import starr0Img from "../../../assets/images/v8bytecode/starr0.webp";
import addr0Img from "../../../assets/images/v8bytecode/addr0.webp";

v8 엔진은 javascript를 컴파일할 때 parser는 abstract syntax tree를 생성합니다.
(이떄 구문트리는 javascript의 syntax를 트리형태로 만든 것)
이후 interpreter인 Ignition는 syntax를 트리를 bytecode로 변환합니다.
최적화 컴파일러 TurboFan는 최종적으로 bytecode를 가져와서 최적화된 기계어 코드를 생성합니다.

<Image
  src={jspipelineImg}
  alt="V8 엔진 JavaScript 파이프라인"
  widths={[640, 1280]}
  sizes="(max-width: 640px) 100vw, 640px"
  formats={["avif", "webp"]}
  quality={80}
  loading="lazy"
  decoding="async"
/>

이렇게 인터프리터와 컴파일러가 동시에 존재하는 이유는 시동시간과 시동속도의 트레이드오프를 해결하기 위한 JIT전략때문에 존재합니다.
Ignition는 코드를 한 줄 한 줄 읽어서 바로 실행합니다.
반면 TurboFan는 자주쓰이는 코드를 CPU에게 최적화된 기계어로 변환합니다.
Ignition는 느리지만 해석할때 반복문이나 특정함수(Hot Spot)를 감지하면 TurboFan을 호출하여 최적화해서 실행합니다.

```javascript
//node.js에서 bytecode 뜯어보는 방법
node --print-bytecode --eval 1+1
```

bytecode에서 중요한것은 **Accumulator Register**입니다.
bytecode는 javascript의 모든 기능을 구성하는 작업 요소입니다.

```
Add(더하기), Typeof(타입)
LdaNamedProperty, CreateObjectLiteral, SuspendGenerator...

//bytecodes.h 참고
```

bytecode는 입력값과 출력값을 저장할 register를 필요로합니다.
v8의 Ignition는 r0, r1과 같은 일반 레지스터와 **Accumulator Register**를 사용합니다.

Accumulator Register는 `Add r1`같이 'r1과 어큐물레이터에 있는 값을 더해'를 짧게 적음으로 바이트 코드 길이를 줄이고 메모리를 절약할 수 있게 만듭니다.

### 실행 예시

```javascript
function incrementX(obj) {
  return 1 + obj.x;
}

incrementX({ x: 42 });
```

1. stackCheck : 스택 메모리가 충분한지 검사

   <Image
     src={ldaSmiImg}
     alt="LdaSmi [1] bytecode"
     widths={[400, 800]}
     sizes="(max-width: 640px) 100vw, 400px"
     formats={["avif", "webp"]}
     quality={80}
     loading="lazy"
     decoding="async"
   />

2. LdaSmi [1] : Load accumulator Smi (Small Integer) (1을 어큐물레이터에 넣기)

   <Image
     src={starr0Img}
     alt="Star r0 bytecode"
     widths={[400, 800]}
     sizes="(max-width: 640px) 100vw, 400px"
     formats={["avif", "webp"]}
     quality={80}
     loading="lazy"
     decoding="async"
   />

3. Star r0 : 어큐뮬레이터에 있는 값(1)을 레지스터 r0에 복사해서 저장

```
- length: 1
           0: 0x2ddf8db91611 <String[1]: x>
```

4. LdaNamedProperty a0, [0], [4] :(obj.x를 가져오기)
   <Image
     src={addr0Img}
     alt="Add r0 bytecode"
     widths={[400, 800]}
     sizes="(max-width: 640px) 100vw, 400px"
     formats={["avif", "webp"]}
     quality={80}
     loading="lazy"
     decoding="async"
   />
5. Add r0, [6] : 더하기
6. Return

```
$ node --print-bytecode incrementX.js

[generating bytecode for function: incrementX]
Parameter count 2
Frame size 8
  12 E> 0x2ddf8802cf6e @    StackCheck
  19 S> 0x2ddf8802cf6f @    LdaSmi [1]
        0x2ddf8802cf71 @    Star r0
  34 E> 0x2ddf8802cf73 @    LdaNamedProperty a0, [0], [4]
  28 E> 0x2ddf8802cf77 @    Add r0, [6]
  36 S> 0x2ddf8802cf7a @    Return
```

---

#### 참고자료

[Just In Time Compilation (JITC)](https://jewelism.github.io/js/)
[Understanding V8’s Bytecode](https://medium.com/dailyjs/understanding-v8s-bytecode-317d46c94775)
